{
  "version": 3,
  "sources": ["../../../src/utils/i18n-normalizer/i18n-normalizer.js", "../../../src/utils/i18n-importer/provider.js", "../../../src/utils/i18n-importer/implementation.js", "../../../src/utils/algorithms/traverse-up-dom.js", "../../../src/utils/algorithms/get-lang-from-element.util.js", "../../../src/utils/algorithms/iterable-weak-struct.js", "../../../src/element-lang-observer/element-lang-observer.util.js", "../../../src/utils/algorithms/get-translate-from-element.util.js", "../../../src/utils/i18n-importer/i18n-importer.js", "../../../src/utils/store/translation-store.js", "../../../src/utils/store-map/store-map.js", "../../../src/key-parser/key-ast.util.js", "../../../src/utils/algorithms/number.utils.js", "../../../src/utils/algorithms/time.utils.js", "../../../src/key-parser/expression-formatters.js", "../../../src/key-parser/capture-expression-values.js", "../../../src/key-parser/priority-calculator.js", "../../../src/utils/algorithms/regex.utils.js", "../../../src/key-parser/template-matcher.js", "../../../src/key-parser/key-parser.util.js", "../../../src/key-parser/value-formatter.js", "../../../src/key-parser/value-parser.util.js", "../../../src/utils/translation-query/translation-query.util.js", "../../../src/utils/html-sanitizer/html-sanitizer.js", "../../../src/utils/tick-time/tick-time.js", "../../../src/utils/i18n-merger/i18n-merger.util.js", "../../../src/html-loader/html-loader.js", "../../../src/custom-elements/i18n-container/i18n-container.element.js", "../../../src/js-api/api.js", "../../../src/entrypoint/browser.js"],
  "sourcesContent": ["/**\n * Checks if import path is valid\n *\n * @param {string} path\n * @returns {{ valid: true } | { valid: false, error: string }}\n */\nexport function validateImportPath (path) {\n  if (typeof path !== 'string') {\n    return { valid: false, error: `expected string instead of ${typeOf(path)}` }\n  }\n  if (path === '') {\n    return { valid: false, error: 'cannot import empty path' }\n  }\n  return { valid: true }\n}\n\n/**\n * Normalize Import Array, eliminating invalid import paths\n *\n * @param {string[]} importArray\n * @returns {{ result: string[]; errors: ErrorList }}\n */\nfunction normalizeImportArray (importArray) {\n  const result = []\n  const errors = []\n  for (const [index, importPath] of importArray.entries()) {\n    const checkResult = validateImportPath(importPath)\n    if (!checkResult.valid) {\n      errors.push({ path: `.[${index}]`, message: `${checkResult.error}, ignoring import` })\n      continue\n    }\n    result.push(importPath)\n  }\n  return { result, errors }\n}\n\n/**\n * Normalize Import string, into an normalized import array\n *\n * @param {unknown} extdensVal\n * @returns {{ result: string[]; errors: ErrorList }}\n */\nfunction normalizesImportValue (extdensVal) {\n  if (extdensVal === '') {\n    return { result: [], errors: [{ path: '', message: 'cannot import empty path, ignoring import' }] }\n  }\n\n  if (typeof extdensVal === 'string') {\n    return { result: [extdensVal], errors: [] }\n  }\n\n  if (Array.isArray(extdensVal)) {\n    return normalizeImportArray(extdensVal)\n  }\n\n  return {\n    result: [],\n    errors: [{ path: '', message: `expected string or string array (string[]) instead of ${typeOf(extdensVal)}` }],\n  }\n}\n\n/**\n * Normalize Translations, eliminatin invalid entries\n *\n * @param {Translations} [translations]\n * @returns {{ result: Translations; errors: ErrorList }}\n */\nexport function normalizeTranslations (translations) {\n  if (!isPlainObject(translations)) {\n    return {\n      result: {},\n      errors: [{ path: '', message: `expected a plain object instead of ${typeOf(translations)}` }],\n    }\n  }\n\n  const validEntries = []\n  const errors = []\n\n  for (const [key, value] of Object.entries(translations)) {\n    if (typeof value !== 'string') {\n      errors.push({ path: properyPath(key), message: `expected string instead of ${typeOf(value)}` })\n      continue\n    }\n    validEntries.push([key, value])\n  }\n\n  return { result: Object.fromEntries(validEntries), errors }\n}\n\n/**\n * Normalizes the i18n definition model data\n *\n * @param {I18nDefinition} data - target i18n definition to be normalized\n *\n * @returns {{ result: NormalizedI18nDefinition; errors: ErrorList }} normalized i18n definition\n */\nexport function normalizeI18nDefinition (data) {\n  if (data === '') {\n    return {\n      result: { import: [], translations: {} },\n      errors: [{ path: '', message: 'cannot import empty path, ignoring import' }],\n    }\n  }\n\n  if (typeof data === 'string') {\n    return { result: { import: [data], translations: {} }, errors: [] }\n  }\n\n  if (Array.isArray(data)) {\n    const importArrayResult = normalizeImportArray(data)\n    const errors = importArrayResult.errors\n    const result = { import: importArrayResult.result, translations: {} }\n    return { result, errors }\n  }\n\n  if (!isPlainObject(data)) {\n    return { result: { import: [], translations: {} }, errors: [{ path: '', message: 'invalid type' }] }\n  }\n\n  const errors = []\n  const hasimport = Object.hasOwn(data, 'import')\n  const hasTranslations = Object.hasOwn(data, 'translations')\n\n  const importValue = (() => {\n    if (!hasimport) { return [] }\n    const importValueResult = normalizesImportValue(data.import)\n    errors.push(...importValueResult.errors.map(({ path, message }) => ({ path: mergePath('.import', path), message })))\n    return importValueResult.result\n  })()\n\n  const translationsValue = (() => {\n    if (!hasTranslations) { return {} }\n    const translationsValueResult = normalizeTranslations(data.translations)\n    errors.push(...translationsValueResult.errors.map(({ path, message }) => ({ path: mergePath('.translations', path), message })))\n    return translationsValueResult.result\n  })()\n\n  if (hasimport || hasTranslations) {\n    return {\n      result: { import: importValue, translations: translationsValue },\n      errors,\n    }\n  }\n\n  return {\n    result: { import: [], translations: {} },\n    errors: [{ path: '', message: 'invalid object, the object must have \"import\" or \"translations\" keys' }],\n  }\n}\n\n/**\n * Normalizes the i18n definition map\n *\n * @param {I18nDefinitionMap} data - target i18n definition map to be normalized\n *\n * @returns {NormalizationResult} normalized i18n definition map\n */\nexport function normalizeI18nDefinitionMap (data) {\n  const errors = []\n  const warnings = []\n  const normalizedEntries = []\n\n  for (const [localeString, i18nDefninition] of Object.entries(data)) {\n    let locale\n    try {\n      locale = new Intl.Locale(localeString)\n    } catch {\n      errors.push({\n        path: properyPath(localeString),\n        message: `invalid locale \"${localeString}\", it will be ignored`,\n      })\n      continue\n    }\n\n    const { baseName } = locale\n    if (baseName !== localeString) {\n      if (data[baseName]) {\n        errors.push({\n          path: properyPath(localeString),\n          message: `invalid locale \"${localeString}\", it also conflicts with correct locale \"${baseName}\", it will be ignored`,\n        })\n        continue\n      } else {\n        warnings.push({\n          path: properyPath(localeString),\n          message: `invalid locale \"${localeString}\", fixed to locale \"${baseName}\"`,\n        })\n      }\n    }\n\n    const normalizedResult = normalizeI18nDefinition(i18nDefninition)\n    if (normalizedResult.errors.length) {\n      const propPath = properyPath(localeString)\n      errors.push(...normalizedResult.errors.map(({ path, message }) => ({ path: mergePath(propPath, path), message })))\n    }\n\n    normalizedEntries.push([baseName, normalizedResult.result])\n  }\n\n  return { result: Object.fromEntries(normalizedEntries), warnings, errors }\n}\n\n/**\n * @param {unknown} targetVar\n * @returns type of variable\n */\nconst typeOf = (targetVar) => targetVar == null ? String(targetVar) : typeof targetVar\n\n/**\n * @param {unknown} value\n * @returns {value is Record<string, unknown>}\n */\nconst isPlainObject = (value) => value?.constructor === Object\n\n/**\n * Transforms property name to a valid property path so it can be used to chain with other properties\n * @param {string} propName - object property key\n * @returns .`propName` for simple popery names, otherwise .[`propName`]\n */\nconst properyPath = (propName) => /^[a-z][a-z\\d]*$/i.test(propName) ? `.${propName}` : `.[${JSON.stringify(propName)}]`\n\n/**\n * Merge 2 propery paths\n * @param {string} prop1 - target property path\n * @param {string} prop2 - property path to merge with target\n * @returns merged property path\n */\nconst mergePath = (prop1, prop2) => prop1 + (prop2 === '.' || prop2.startsWith('.[') ? prop2.substring(1) : prop2)\n\n/// Type definitions\n\n/** @typedef {Record<string, string>} Translations */\n\n/** @typedef { { import: string[] , translations: Translations}} NormalizedI18nDefinition */\n\n/** @typedef {Record<string, NormalizedI18nDefinition>} NormalizedI18nDefinitionMap */\n\n/** @typedef {string | string[] | { import?: string[] | string, translations: Translations} | { import: string[] | string, translations?: Translations}} I18nDefinition */\n\n/** @typedef {Record<string, I18nDefinition>} I18nDefinitionMap */\n\n/** @typedef {{ path: string, message: string}[]} ErrorList */\n\n/**\n * @typedef {object} NormalizationResult\n * @property {NormalizedI18nDefinitionMap} result\n * @property {ErrorList} warnings\n * @property {ErrorList} errors\n */\n", "const defaultImplementation = Object.freeze({\n  importTranslations: () => ((console.error('importLanguage not implemented'), Promise.resolve({}))),\n  importI18nJson: () => ((console.error('importLanguage not implemented'), Promise.resolve({}))),\n})\n\n/** @type {Implementation} */\nexport const implementation = Object.seal({\n  ...defaultImplementation,\n})\n\n/**\n * @param {Implementation} newImpl - new implementation to use on the application\n */\nexport function provide (newImpl) {\n  if (typeof newImpl?.importTranslations === 'function') {\n    implementation.importTranslations = newImpl.importTranslations\n  }\n  if (typeof newImpl?.importI18nJson === 'function') {\n    implementation.importI18nJson = newImpl.importI18nJson\n  }\n}\n\n/**\n * @typedef {Record<string, string>} Translations\n */\n\n/**\n * @typedef {object} I18nDefinition\n * @property {string | string[]} [import]    - Additional files to import to the definition\n * @property {Translations}      translations - translaion map\n */\n\n/**\n * @typedef {Record<string, I18nDefinition>} I18nDefinitionMap\n */\n\n/**\n * @typedef {object} Implementation\n * @property {ImportTranslations} importTranslations - {@link ImportTranslations} implementation function\n * @property {ImportI18nJson} importI18nJson - {@link ImportTranslations} implementation function\n */\n\n/**\n * @callback ImportTranslations\n *\n * Imports a {@link Translations} from an URL\n *\n * @param {string | URL} url - target URL\n * @param {string | URL} base - Base URL to use when `url` uses relative url\n * @returns {Promise<Translations>} promise that results imported {@link Translations} object on finish\n */\n\n/**\n * @callback ImportI18nJson\n *\n * Imports a {@link I18nDefinitionMap} from an URL\n *\n * @param {string} url - target URL\n * @param {string} base - Base URL to use when `url` uses relative url\n * @returns {Promise<I18nDefinitionMap>} promise that results imported {@link I18nDefinitionMap} object on finish\n */\n", "import { normalizeI18nDefinitionMap, normalizeTranslations } from '../i18n-normalizer/i18n-normalizer.js'\nimport { provide } from './provider.js'\n\n/** @type {import('./provider.js').ImportTranslations} */\nexport async function importTranslations (url, baseUrl) {\n  const absoluteUrl = new URL(url, baseUrl)\n  const response = await fetch(absoluteUrl)\n  const json = await response.json()\n  const normalizeResult = normalizeTranslations(json)\n  normalizeResult.errors.forEach((error) => console.error('Error on %s::%s, %s', absoluteUrl.href, error.path, error.message))\n  return normalizeResult.result\n}\n\n/** @type {import('./provider.js').ImportI18nJson} */\nexport async function importI18nJson (url, baseUrl) {\n  const absoluteUrl = new URL(url, baseUrl)\n  const response = await fetch(absoluteUrl)\n  const json = await response.json()\n  const normalizeResult = normalizeI18nDefinitionMap(json)\n  normalizeResult.errors.forEach((error) => console.error('Error on %s::%s, %s', absoluteUrl.href, error.path, error.message))\n  normalizeResult.warnings.forEach((warning) => console.warn('Warning on %s::%s, %s', absoluteUrl.href, warning.path, warning.message))\n  return normalizeResult.result\n}\n\nprovide({\n  importTranslations,\n  importI18nJson,\n})\n", "/**\n * Traverse up in the document DOM closest element by passing shadow DOM\n *\n * @param {Element} targetElement\n */\nexport function * traverseUpDom (targetElement) {\n  let el = targetElement\n  while (el != null) {\n    yield el\n    const { parentNode, parentElement } = el\n    if (parentNode instanceof ShadowRoot) {\n      el = parentNode.host\n      continue\n    }\n    if (parentNode instanceof Document || parentElement == null) {\n      return\n    }\n    el = parentElement\n  }\n}\n\n/**\n * Traverse up in the document DOM closest element by passing shadow DOM, passing throug slots\n *\n * @param {Element} targetElement\n */\nexport function * traverseUpDomWithSlots (targetElement) {\n  let el = targetElement\n  while (el != null) {\n    yield el\n    const { parentNode, parentElement, assignedSlot } = el\n    if (assignedSlot) {\n      el = assignedSlot\n      continue\n    }\n    if (parentNode instanceof ShadowRoot) {\n      el = parentNode.host\n      continue\n    }\n    if (parentNode instanceof Document || parentElement == null) {\n      return\n    }\n    el = parentElement\n  }\n}\n", "import { traverseUpDomWithSlots } from './traverse-up-dom.js'\n\n/**\n * @param {Element} element\n * @returns {string} fallback language\n */\nfunction getFallbackLanguage (element) {\n  const root = element.ownerDocument.defaultView ?? globalThis\n  if (!root.navigator) {\n    // OS/node/browser independent way of obtaining the default locale\n    return Intl.DateTimeFormat().resolvedOptions().locale\n  }\n  const langs = root.navigator.languages || [root.navigator.language]\n  return langs[0]\n}\n\n/**\n * @param {Element} elementWithLangAttr\n * @param {string} invalidLanguage\n * @returns {string} corrected language\n */\nfunction handleInvalidLanguage (elementWithLangAttr, invalidLanguage) {\n  if (elementWithLangAttr === elementWithLangAttr.ownerDocument.documentElement) {\n    return getFallbackLanguage(elementWithLangAttr)\n  } else if (elementWithLangAttr.parentNode instanceof ShadowRoot) {\n    return getLanguageFromElement(elementWithLangAttr.parentNode.host)\n  }\n  return getLanguageFromElement(elementWithLangAttr.parentElement)\n}\n\n/**\n * Gets the currently applied language of the element\n *\n * @param {Element | null} element\n * @returns {string} element language\n */\nexport function getLanguageFromElement (element) {\n  if (element == null) {\n    return navigator.language\n  }\n  for (const node of traverseUpDomWithSlots(element)) {\n    const langValue = node.getAttribute('lang')\n    if (!langValue) continue\n    try {\n      const locale = new Intl.Locale(langValue)\n      const { language, region } = locale\n      if (region == null) {\n        return language\n      }\n      return `${language}-${region}`\n    } catch (e) {\n      return handleInvalidLanguage(node, langValue)\n    }\n  }\n\n  return getFallbackLanguage(element)\n}\n", "/**\n * @constructor\n * @template {object} K\n * @template V\n */\nexport class IterableWeakMap {\n  /**\n   *\n   * @param {Iterable<readonly [K, V]>} [iterable]\n   */\n  constructor (iterable = []) {\n    for (const [key, value] of iterable) { this.set(key, value) }\n  }\n\n  /** @returns {number} */\n  get size () {\n    return dataOf(this).keySet.size\n  }\n\n  /**\n   *\n   * @param {K} key\n   */\n  delete (key) {\n    const { keySet, refWeakMap } = dataOf(this)\n    const entry = refWeakMap.get(key)\n    if (!entry) return false\n    keySet.delete(entry.ref)\n    refWeakMap.delete(key)\n    return true\n  }\n\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * @returns {IterableIterator<[K, V]>}\n   */\n  * entries () {\n    const { refWeakMap } = dataOf(this)\n    for (const key of this.keys()) {\n      const entry = refWeakMap.get(key)\n      if (entry) {\n        yield [key, entry.value]\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {(value : V, key : K, map : this) => void} callback\n   * @param {*} [thisArg]\n   */\n  forEach (callback, thisArg) {\n    for (const [key, value] of this.entries()) { callback.call(thisArg, value, key, this) }\n  }\n\n  /**\n   *\n   * @param {K} key\n   * @returns {V | undefined}\n   */\n  get (key) {\n    return dataOf(this).refWeakMap.get(key)?.value\n  }\n\n  /**\n   *\n   * @param {K} key\n   */\n  has (key) {\n    return dataOf(this).refWeakMap.has(key)\n  }\n\n  * keys () {\n    const { keySet } = dataOf(this)\n    const array = Array.from(keySet)\n    for (const ref of array) {\n      const deref = ref.deref()\n      if (!deref) {\n        keySet.delete(ref)\n        continue\n      }\n      yield deref\n    }\n  }\n\n  /**\n   *\n   * @param {K} key\n   * @param {V} value\n   * @returns\n   */\n  set (key, value) {\n    const { keySet, refWeakMap } = dataOf(this)\n    const refVal = refWeakMap.get(key)\n    if (refVal !== undefined) {\n      refVal.value = value\n      return this\n    }\n    const ref = new WeakRef(key)\n    refWeakMap.set(key, { ref, value })\n    keySet.add(ref)\n    return this\n  }\n\n  /**\n   * @returns {IterableIterator<V>}\n   */\n  * values () {\n    for (const [, value] of this.entries()) { yield value }\n  }\n}\n\n/**\n * @constructor\n * @template {object} V\n */\nexport class IterableWeakSet {\n  /**\n   *\n   * @param {Iterable<V>} [iterable]\n   */\n  constructor (iterable = []) {\n    for (const value of iterable) { this.add(value) }\n  }\n\n  /** @returns {number} */\n  get size () {\n    return dataOf(this).keySet.size\n  }\n\n  /**\n   *\n   * @param {V} key\n   */\n  delete (key) {\n    const { keySet, refWeakMap } = dataOf(this)\n    const entry = refWeakMap.get(key)\n    if (!entry) return false\n    keySet.delete(entry.ref)\n    refWeakMap.delete(key)\n    return true\n  }\n\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * @returns {IterableIterator<V>}\n   */\n  * entries () {\n    for (const value of this.keys()) { yield value }\n  }\n\n  /**\n   *\n   * @param {(value : V, set : this) => void} callback\n   * @param {*} [thisArg]\n   */\n  forEach (callback, thisArg) {\n    for (const value of this.entries()) { callback.call(thisArg, value, this) }\n  }\n\n  /**\n   *\n   * @param {V} value\n   */\n  has (value) {\n    return dataOf(this).refWeakMap.has(value)\n  }\n\n  * keys () {\n    const { keySet } = dataOf(this)\n    const array = Array.from(keySet)\n    for (const ref of array) {\n      const deref = ref.deref()\n      if (!deref) {\n        keySet.delete(ref)\n        continue\n      }\n      yield deref\n    }\n  }\n\n  /**\n   *\n   * @param {V} value\n   * @returns\n   */\n  add (value) {\n    const { keySet, refWeakMap } = dataOf(this)\n    if (refWeakMap.has(value)) {\n      return this\n    }\n    const ref = new WeakRef(value)\n    refWeakMap.set(value, { ref, value: true })\n    keySet.add(ref)\n    return this\n  }\n\n  /**\n   * @returns {IterableIterator<V>}\n   */\n  * values () {\n    for (const value of this.keys()) { yield value }\n  }\n}\n\nconst dataOf = (() => {\n  /**\n   * @template {object} K\n   * @template V\n   *\n   * @typedef {object} IterableWeakMapData\n   *\n   * @property {WeakMap<K, {ref: WeakRef<K> , value: V}>} refWeakMap\n   * @property {Set<WeakRef<K>>} keySet\n   *\n   */\n\n  /**\n   * @type {WeakMap<*, IterableWeakMapData<object,*>>} valueMap\n   */\n  const map = new WeakMap()\n\n  /**\n   * @param {IterableWeakSet<object> | IterableWeakMap<object, *>} iter\n   */\n  function init (iter) {\n    const keySet = new Set()\n    const refWeakMap = new WeakMap()\n    const result = { keySet, refWeakMap }\n    map.set(iter, result)\n    return result\n  }\n\n  /**\n     * @template {object} K\n     * @template V\n     * @param {IterableWeakSet<K> | IterableWeakMap<K, V>} iter\n     * @returns {IterableWeakMapData<K, V>} iter\n     */\n  function getData (iter) {\n    return map.get(iter) ?? init(iter)\n  }\n  return getData\n})()\n\nexport default IterableWeakMap\n", "import { getLanguageFromElement } from '../utils/algorithms/get-lang-from-element.util.js'\nimport { IterableWeakMap, IterableWeakSet } from '../utils/algorithms/iterable-weak-struct.js'\n\n/** @type {IterableWeakMap<Node, ObserveInfomation>} */\nconst rootNodes = new IterableWeakMap()\n\nconst data = Symbol('ElementLangObserverData')\n\n/** @type {WeakMap<Element, {currentLang: string, observers: Set<ElementLangObserver>}>} */\nconst observingElementsInfo = new WeakMap()\n\nexport const domRootLangDispatchListener = {\n  /**\n   *\n   * @param {Element | Document} target,\n   * @param {EventListenerOrEventListenerObject} callback\n   * @param {boolean | AddEventListenerOptions} options\n   * @returns\n   */\n  onDispatchOnRoot: (target, callback, options) => {\n    target.addEventListener(rootEventName, callback, options)\n    return {\n      removeListener: () => target.removeEventListener(rootEventName, callback, options),\n    }\n  },\n}\n\nexport const rootEventName = 'lang-change-dispatched'\n\nexport class ElementLangObserver {\n  /**\n   *\n   * @param {ElementLangObserverHandler} callback\n   */\n  constructor (callback) {\n    this[data] = {\n      callback,\n    }\n  }\n\n  /**\n   *\n   * @param {Element} element\n   */\n  observe (element) {\n    observeLangFromElement(element, this)\n  }\n\n  /**\n   *\n   * @param {Element} element\n   */\n  unobserve (element) {\n    unobserveLangFromElement(element, this)\n  }\n}\n\n/**\n * @type {MutationObserverInit}\n */\nconst mutationProperties = Object.freeze({\n  attributes: true,\n  attributeFilter: ['lang'],\n  subtree: true,\n})\n\n/**\n * callback of MutationObserver that detect language changes\n * @param {MutationRecord[]} records\n */\nfunction langMutationObserverCallback (records) {\n  const triggeredNodes = new Set()\n  const validatedNodes = new Set()\n  const rootNodesToTrigger = new Set()\n  for (const record of records) {\n    const rootNode = record.target.getRootNode()\n    rootNodesToTrigger.add(rootNode)\n    const observingElements = rootNodes.get(rootNode)?.observingElements\n    observingElements && observingElements.forEach((node) => {\n      if (validatedNodes.has(node)) {\n        return\n      }\n      validatedNodes.add(node)\n      const info = observingElementsInfo.get(node)\n      if (!info) {\n        return\n      }\n      const oldLang = info.currentLang\n      const newLang = getLanguageFromElement(node)\n      if (newLang === oldLang) {\n        return\n      }\n      info.currentLang = newLang\n      info.observers.forEach(observer => {\n        observer[data].callback([{\n          target: node,\n          causingElement: record.target,\n          previousLanguage: oldLang,\n          language: newLang,\n        }])\n      })\n      triggeredNodes.add(node)\n    })\n  }\n  const event = new CustomEvent(rootEventName, { detail: { triggeredNodes: Array.from(triggeredNodes) } })\n  for (const node of rootNodesToTrigger) {\n    node.dispatchEvent(event)\n  }\n}\n\n/**\n * Creates an\n * @param {Node} targetNode\n * @returns\n */\nfunction createObserver (targetNode) {\n  const observer = new MutationObserver(langMutationObserverCallback)\n  observer.observe(targetNode, mutationProperties)\n  return observer\n}\n\n/**\n *\n * @param {Node} rootNode\n * @param {Element} element\n */\nfunction traverseRootNode (rootNode, element) {\n  const observeInfomation = rootNodes.get(rootNode)\n  if (observeInfomation) {\n    observeInfomation.observingElements.add(element)\n  } else {\n    rootNodes.set(rootNode, {\n      observer: createObserver(rootNode),\n      observingElements: new IterableWeakSet([element]),\n      targetNode: new WeakRef(rootNode),\n    })\n  }\n\n  if (rootNode instanceof ShadowRoot) {\n    const host = rootNode.host\n    traverseRootNode(host.getRootNode(), element)\n  }\n}\n\n/**\n *\n * @param {Element} element\n * @param {ElementLangObserver} observer\n */\nexport function observeLangFromElement (element, observer) {\n  const oldVal = observingElementsInfo.get(element)\n  if (oldVal) {\n    oldVal.observers.add(observer)\n    return\n  }\n  observingElementsInfo.set(element, {\n    currentLang: getLanguageFromElement(element),\n    observers: new Set([observer]),\n  })\n  const rootNode = element.getRootNode()\n  traverseRootNode(rootNode, element)\n}\n\n/**\n *\n * @param {Element} element\n * @param {ElementLangObserver} observer\n */\nexport function unobserveLangFromElement (element, observer) {\n  const observers = observingElementsInfo.get(element)?.observers\n  if (!observers) {\n    return\n  }\n  observers.delete(observer)\n  if (observers.size > 0) {\n    return\n  }\n\n  observingElementsInfo.delete(element)\n  for (const [rootNode, info] of rootNodes.entries()) {\n    const { observingElements, observer } = info\n    observingElements.delete(element)\n    if (observingElements.size <= 0) {\n      observer.disconnect()\n      rootNodes.delete(rootNode)\n    }\n  }\n}\n\n/**\n * @typedef {object} ObserveInfomation\n * @property {IterableWeakSet<Element>} observingElements - the elements that will react when `targetNode` detects a language change\n * @property {MutationObserver} observer - mutationObserver applied to `targetNode`\n * @property {WeakRef<Node>} targetNode - rootNode of the current DOM (<html> or ShadowRoot)\n */\n\n/**\n * @callback ElementLangObserverHandler\n * @param {ElementLangObserverRecord[]} records\n * @returns {void}\n */\n\n/**\n * @typedef {object} ElementLangObserverRecord\n * @property {Element} target - observer target\n * @property {Node} causingElement - element that changed language\n * @property {string} previousLanguage - previous lang value\n * @property {string} language - new lang value\n */\n", "import { traverseUpDomWithSlots } from './traverse-up-dom.js'\n\n/**\n * Check wheter the element is translatable\n *\n * It respects the `translate` global attribute:\n *\n * >   The translate attribute is an enumerated attribute that is used to\n * > specify whether an element's attribute values and the values of its\n * > Text node children are to be translated when the page is localized,\n * > or whether to leave them unchanged.\n *\n * The tranlate will apply to all elements, including non-HTML elements\n *\n * @see https://html.spec.whatwg.org/multipage/dom.html#attr-translate\n * @param {Element} element\n * @returns {boolean} true if element is translatable, false otherwise\n */\nexport function isElementTranslatable (element) {\n  // the vast majority of element are HTMLElement, so validating it first is good\n  if (element instanceof HTMLElement) {\n    return element.translate\n  }\n  if (element == null) {\n    return false\n  }\n  for (const node of traverseUpDomWithSlots(element)) {\n    if (node instanceof HTMLElement) {\n      return node.translate\n    }\n    const translateValue = node.getAttribute('translate')\n    if (translateValue == null) continue\n\n    if (translateValue === '' || translateValue === 'yes') {\n      return true\n    } else if (translateValue === 'no') {\n      return false\n    }\n  }\n  return true\n}\n", "import { implementation } from './provider.js'\n\n/** @type {ImportTranslations} */\nexport const importTranslations = (url, base) => implementation.importTranslations(url, base)\n\n/** @type {ImportI18nJson} */\nexport const importI18nJson = (url, base) => implementation.importI18nJson(url, base)\n\n/** @typedef {import('./provider.js').ImportTranslations} ImportTranslations */\n/** @typedef {import('./provider.js').ImportI18nJson} ImportI18nJson */\n/** @typedef {import('./provider.js').I18nDefinitionMap} I18nDefinitionMap */\n", "import { importTranslations } from '../i18n-importer/i18n-importer.js'\nimport { normalizeI18nDefinitionMap } from '../i18n-normalizer/i18n-normalizer.js'\n\nconst emptyObj = Object.freeze({})\nconst intialDataStore = Object.freeze({\n  languages: emptyObj,\n  location: '',\n})\n\n/**\n * Normalizes `StoreDataEntry.data`\n * @param {StoreDataEntry} data\n */\nfunction normalizeTranslationData (data) {\n  const normalizedLanguages = normalizeI18nDefinitionMap(data.languages)\n  normalizedLanguages.errors.forEach((error) => console.error('Error on %s::%s, %s', data.location, error.path, error.message))\n  normalizedLanguages.warnings.forEach((error) => console.warn('Warning on %s::%s, %s', data.location, error.path, error.message))\n  return {\n    location: data.location,\n    languages: structuredClone(normalizedLanguages.result),\n  }\n}\n\n/** @type {WeakMap<TranslationStore, Record<string, Translations>>} */\nconst memoizedTranslationsMap = new WeakMap()\n\n/**\n *\n * @param {TranslationStore} store\n */\nfunction getMemoizedTranslations (store) {\n  const memoizedTranslations = memoizedTranslationsMap.get(store)\n  if (memoizedTranslations) {\n    return memoizedTranslations\n  }\n  /** @type {Record<string, Translations>} */\n  const newMemo = {}\n  memoizedTranslationsMap.set(store, newMemo)\n  return newMemo\n}\n\n/**\n *\n * @param {TranslationStore} store\n * @param {string} locale\n * @returns {Promise<Translations>}\n */\nconst getTranslationsFromData = async (store, locale) => {\n  const computed = getMemoizedTranslations(store)\n  if (computed[locale]) {\n    return computed[locale]\n  }\n  const definition = store.data.languages[locale]\n  if (!definition) {\n    return {}\n  }\n  if (!Array.isArray(definition.import) || definition.import.length <= 0) {\n    return definition.translations\n  }\n  const translationsPromises = definition.import.map(extend => importTranslations(extend, store.data.location))\n  const translationsArray = await Promise.all(translationsPromises)\n  const importedTranslations = translationsArray.reduce((acc, translations) => ({ ...acc, ...translations }))\n\n  computed[locale] = {\n    ...importedTranslations,\n    ...definition.translations,\n  }\n  return computed[locale]\n}\n\n/** @type {TranslationStore} */\nconst StorePrototype = {\n\n  loadTranslations (data) {\n    this.data = normalizeTranslationData(data)\n    memoizedTranslationsMap.delete(this)\n  },\n\n  async translationsFromLanguage (locale) {\n    if (typeof locale === 'string') {\n      return await this.translationsFromLanguage(new Intl.Locale(locale))\n    }\n\n    const memoizedTranslations = getMemoizedTranslations(this)\n\n    if (memoizedTranslations[locale.baseName]) {\n      return memoizedTranslations[locale.baseName]\n    }\n    const languages = [locale.baseName]\n    const intlLang = locale.language\n    if (locale.region != null) {\n      const langRegion = `${intlLang}-${locale.region}`\n      if (!languages.includes(langRegion)) {\n        languages.push(langRegion)\n      }\n    }\n    if (!languages.includes(intlLang)) {\n      languages.push(intlLang)\n    }\n    const translationsPromises = languages.reverse().map(language => getTranslationsFromData(this, language))\n    const translationsArray = await Promise.all(translationsPromises)\n    const result = translationsArray.reduce((acc, translations) => ({ ...acc, ...translations }))\n    memoizedTranslations[locale.baseName] = result\n    return result\n  },\n  data: intialDataStore,\n}\n\n/**\n * Creates a translation store\n * @returns {TranslationStore} new translation store\n */\nexport function i18nTanslationStore () {\n  return Object.create(StorePrototype)\n}\n\n//= == Type declarations\n\n/** @typedef {import('../i18n-normalizer/i18n-normalizer.js').I18nDefinitionMap} I18nDefinitionMap */\n/** @typedef {import('../i18n-normalizer/i18n-normalizer.js').NormalizedI18nDefinitionMap} NormalizedI18nDefinitionMap */\n\n/** @typedef {import('../i18n-normalizer/i18n-normalizer.js').Translations} Translations */\n\n/**\n * @typedef {object} StoreData\n *\n * Data of {@link TranslationStore}\n *\n * @property {NormalizedI18nDefinitionMap} languages - Store data languages\n * @property {string} location - location of stored data, used to get relative path to load additional i18n files\n */\n\n/**\n * @typedef {object} StoreDataEntry\n *\n * Data to used to save in {@link TranslationStore}, it will be normalized to  {@link StoreData} on {@link TranslationStore.loadTranslations} call\n *\n * @property {I18nDefinitionMap} languages - Store data languages\n * @property {string} location - location of stored data, used to get relative path to load additional i18n files\n */\n\n/**\n * @typedef {object} TranslationStore\n *\n * Data to used to save in {@link TranslationStore}, it will be normalized to  {@link StoreData} on {@link TranslationStore.loadTranslations} call\n *\n * @property {(data: StoreDataEntry) => void} loadTranslations - loads translations in data\n * @property {TranslationsFromLanguage} translationsFromLanguage - get stored translations from a locale\n * @property {StoreData} data - Store data where all infomation is saved with loadTranslations()\n */\n\n/**\n * @callback TranslationsFromLanguage\n * @param {string | Intl.Locale} locale - Intl.Locale of a string definition\n * @returns {Promise<Translations>} empty locale, if locale string invalid, otherwise all translations from language\n */\n", "import { i18nTanslationStore } from '../store/translation-store.js'\nimport { traverseUpDom } from '../algorithms/traverse-up-dom.js'\n\nconst fallbackStore = i18nTanslationStore()\n\n/** @type {StoreSearchResult} */\nexport const noStoresFound = Object.freeze({\n  store: fallbackStore,\n})\n\n/** @type {StoreMap} */\nconst map = new WeakMap()\n\n/**\n * Remove assigned store from element\n * @param {Element} element - target element\n */\nexport const unsetStoreOnElement = (element) => {\n  map.delete(element)\n}\n\n/**\n * Checks if there is a translation store set on element\n * @param {Element} element - target element\n */\nexport const isStoreSetOnElement = function (element) {\n  return map.has(element)\n}\n\n/**\n * Assigns a {@link TranslationStore} to an element, overwrites previous if already assigned\n * @param {Element} element - target element\n * @param {TranslationStore} store - store to assign\n */\nexport const setStoreFromElement = (element, store) => {\n  map.set(element, store)\n}\n\n/**\n * Gets stores assigned and inherited from the element\n * @param {Element} target - target Element\n * @yields {StoreSearchResult}\n */\nexport const getStoresInfoFromElement = function * (target) {\n  for (const element of traverseUpDom(target)) {\n    const store = map.get(element)\n    if (store) yield { store, element }\n  }\n  yield noStoresFound\n}\n\n/**\n * @typedef {WeakMap<Element, TranslationStore>} StoreMap\n */\n\n/**\n * @typedef {object} StoreSearchResult\n *\n * Result of {@link getStoresInfoFromElement}\n *\n * @property {TranslationStore} store - store found, or fallback store\n * @property {Element} [element] element where the store is assigned\n */\n\n/**\n * @typedef {import('../store/translation-store.js').TranslationStore} TranslationStore\n */\n", "/**\n * Enum for token types.\n * @enum {number}\n */\nexport const states = {\n  normal: 0,\n  capture: 1,\n  capture_expr: 2,\n  capture_expr_sep: 3,\n  regex: 4,\n  sq_string: 5,\n  dq_string: 6,\n  bt_string: 7,\n  escape: 8,\n\n  previous: 9,\n  previous_ignore: 10,\n}\n\n/**\n * @param {string} char - target string char\n * @returns {number} the Unicode value of the character\n */\nconst ch = (char) => char.charCodeAt(0)\n\nconst defaultNextState = (() => {\n  const state = []\n  state[states.normal] = states.normal\n  state[states.capture] = states.capture_expr\n  state[states.capture_expr] = states.capture_expr\n  state[states.capture_expr_sep] = states.previous_ignore\n  state[states.regex] = states.regex\n  state[states.sq_string] = states.sq_string\n  state[states.dq_string] = states.dq_string\n  state[states.bt_string] = states.bt_string\n  state[states.escape] = states.previous\n  return state\n})()\n\nconst normalState = (() => {\n  const state = []\n  state[ch('{')] = states.capture\n  return state\n})()\n\nconst captureState = (() => {\n  const state = []\n  state[ch('}')] = states.previous\n  state[ch('/')] = states.regex\n  state[ch('\\'')] = states.sq_string\n  state[ch('\"')] = states.dq_string\n  state[ch('`')] = states.bt_string\n  state[ch('\\\\')] = states.escape\n  state[ch('\\t')] = states.capture\n  state[ch(' ')] = states.capture\n  state[ch('\\n')] = states.capture\n  state[ch('|')] = states.capture_expr_sep\n  return state\n})()\n\nconst captureExprState = (() => {\n  const state = []\n  state[ch('\\\\')] = states.previous_ignore\n  state[ch('\\t')] = states.previous_ignore\n  state[ch(' ')] = states.previous_ignore\n  state[ch('|')] = states.previous_ignore\n  state[ch('\\n')] = states.previous_ignore\n  state[ch('}')] = states.previous_ignore\n  return state\n})()\n\nconst regexState = (() => {\n  const state = []\n  state[ch('/')] = states.previous\n  state[ch('\\\\')] = states.escape\n  return state\n})()\n\nconst singleQuoteStringState = (() => {\n  const state = []\n  state[ch('\\'')] = states.previous\n  state[ch('\\\\')] = states.escape\n  return state\n})()\n\nconst doubleQuoteStringState = (() => {\n  const state = []\n  state[ch('\"')] = states.previous\n  state[ch('\\\\')] = states.escape\n  return state\n})()\n\nconst backtickStringState = (() => {\n  const state = []\n  state[ch('`')] = states.previous\n  state[ch('\\\\')] = states.escape\n  return state\n})()\n\nconst stateMachine = (() => {\n  const state = []\n  state[states.normal] = normalState\n  state[states.capture] = captureState\n  state[states.capture_expr] = captureExprState\n  state[states.capture_expr_sep] = []\n  state[states.regex] = regexState\n  state[states.sq_string] = singleQuoteStringState\n  state[states.dq_string] = doubleQuoteStringState\n  state[states.bt_string] = backtickStringState\n  state[states.escape] = []\n  return state\n})()\n\n/**\n * Parses the string into an Abstract Syntac Tree (AST)\n *\n * @param {string} key - target sting\n * @returns {AST} the parsed AST of the target key\n */\nexport function getAST (key) {\n  let currentState = states.normal\n  let currentMachineState = stateMachine[currentState]\n\n  /** @type {AST_In_Progress} */\n  const rootnode = {\n    tokens: [],\n  }\n\n  /** @type {TmpToken} */\n  let currentToken = {\n    parentNode: rootnode,\n    start: 0,\n    end: 0,\n    type: states.normal,\n    childTokens: [],\n  }\n\n  /**\n   * Sets the current state\n   * @param {number} newState\n   */\n  const setCurrentState = (newState) => {\n    currentState = newState\n    currentMachineState = stateMachine[currentState]\n  }\n\n  /**\n   * @param {AST_In_Progress | TmpToken} node\n   * @returns {node is AST_In_Progress}\n   */\n  const isRootNode = (node) => node === rootnode\n\n  /**\n   * sets the current token the parent node or the\n   * @param {number} index\n   */\n  const upOneLevel = (index) => {\n    setCurrentState(/** @type {TmpToken} */(currentToken.parentNode).type ?? states.normal)\n\n    if (currentToken.type === states.escape) {\n      const { parentNode } = currentToken\n\n      if (isRootNode(parentNode)) {\n        currentToken = /** @type {TmpToken} */(rootnode.tokens.pop())\n        return\n      }\n      currentToken = parentNode\n      return\n    }\n\n    currentToken.end = index + 1\n\n    const { parentNode } = currentToken\n\n    if (isRootNode(parentNode)) {\n      parentNode.tokens.push(currentToken)\n      currentToken = {\n        parentNode,\n        start: index + 1,\n        end: index + 1,\n        type: states.normal,\n        childTokens: [],\n      }\n      return\n    }\n\n    parentNode.childTokens.push(currentToken)\n    currentToken = parentNode\n  }\n\n  const length = key.length\n  for (let i = 0; i < length; i++) {\n    const ch = key.charCodeAt(i)\n\n    const nextState = currentMachineState[ch] ?? defaultNextState[currentState]\n    if (nextState == null || nextState === currentState) continue\n\n    if (nextState === states.previous) {\n      upOneLevel(i)\n      continue\n    }\n\n    if (nextState === states.previous_ignore) {\n      upOneLevel(i - 1)\n      i--\n      continue\n    }\n\n    if (currentState === states.normal) {\n      // at this point the next state is always `states.capture`\n      if (key.charCodeAt(i + 1) === ch) {\n        i++\n        continue\n      }\n\n      currentToken.end = i\n      if (currentToken.end > currentToken.start) {\n        rootnode.tokens.push(currentToken)\n      }\n      currentToken = {\n        parentNode: rootnode,\n        start: i,\n        end: i,\n        type: nextState,\n        childTokens: [],\n      }\n    } else {\n      const newToken = {\n        parentNode: currentToken,\n        start: i,\n        end: i,\n        type: nextState,\n        childTokens: [],\n      }\n      currentToken = newToken\n    }\n    setCurrentState(nextState)\n  }\n\n  currentToken.end = key.length\n  if (currentToken.end > currentToken.start) {\n    rootnode.tokens.push(currentToken)\n  }\n\n  /** @type {(a: TmpToken) => Token} */\n  const toToken = ({ start, end, type, childTokens }) => {\n    const substring = key.substring(start, end)\n    const text = type === states.normal ? substring.replaceAll('{{', '{') : substring\n\n    return {\n      start,\n      end,\n      type,\n      text,\n      childTokens: childTokens.map(toToken),\n    }\n  }\n\n  return {\n    key,\n    tokens: rootnode.tokens.map(toToken),\n  }\n}\n\n/**\n * @typedef {object} AST\n *\n * Abstract syntax tree (AST), or just syntax tree, A parse tree is a visual representation of the\n * syntactic structure of a piece of source code, as produced by a parser.\n * It shows the hierarchy of the elements in the code and the relationships between them.\n *\n * @property {string} key - the target key used to create the key\n * @property {Token[]} tokens - the direct descentdant of the root tree\n *\n */\n\n/**\n * @typedef {object} AST_In_Progress\n *\n * A \"work in progress\" AST, it is just a object used to build the {@see AST}\n *\n * @property {TmpToken[]} tokens - the direct descentdant of the root tree\n */\n\n/**\n * @typedef {object} Token\n * Represents a Node in the {@link AST}\n *\n * @property {number} start - text ocurrent starting position (start index), number is inclusive\n * @property {number} end - text ocurrent ending position (end index), number is exclusive\n * @property {typeof states[keyof typeof states]} type - the node type\n * @property {string} text - substring of the {@link AST.key} with `start` and `end`\n * @property {Token[]} childTokens - direct child tokens of the node\n */\n\n/**\n * @typedef {object} TmpToken\n * Temporary {@link Token}, used to create the final {@link Token}\n *\n * @property {AST_In_Progress | TmpToken} parentNode - parent node\n * @property {number} start - text ocurrent starting position (start index), number is inclusive\n * @property {number} end - text ocurrent ending position (end index), number is exclusive\n * @property {typeof states[keyof typeof states]} type - the node type\n * @property {TmpToken[]} childTokens - direct child temporary tokens of the node\n */\n", "/**\n * Checks if string is an integer, it accepts all numeric notations\n *\n * @param {string} str - target string\n * @returns true if `str`is a number, false otherwise\n */\nexport function isNumeric (str) {\n  return typeof str === 'string' && str.trim() === str && !isNaN(Number(str)) && !isNaN(parseFloat(str))\n}\n\n/**\n * Checks if string is an integer, in this case, it only accepts number sign and digits\n *\n * @param {string} str - target string\n * @returns true if `str`is an integer, false otherwise\n */\nexport function isInteger (str) {\n  return typeof str === 'string' && /^[+-]?[0-9]+$/.test(str)\n}\n", "/**\n * Parses ISO-8601 text\n *\n * @param {string} text - ISO8601 input as string\n * @returns {number} the representing ISO date as milliseconds from UNIX time on valid input, NaN on invalid input\n */\nexport function parseISO8601 (text) {\n  if (typeof text !== 'string') {\n    return NaN\n  }\n  const iso8601Regex =\n    /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d)/\n  return !text.match(iso8601Regex) ? NaN : Date.parse(text)\n}\n\n/**\n * Returns current time and memoizes it for the duration of a frame\n *\n * This function exists because many operations related to relative time\n * relies on current time, calling Date.now() continuosly not only returns\n * different result each call, it is expensive. Calling it continuously\n * will affect performance\n *\n * The impact of different results in Date.now() is that each frame you may,\n * see inconsistent results on all ticking elements in a screen (one or two elements jumps 2 seconds,\n * or no seconds at all, while others are ok)\n *\n * @returns {number} the current time, or the time of first call if called more than once during a frame\n */\nexport const timeNowFrame = (() => {\n  /** @type {number | null} */\n  let frameTime = null\n\n  return function timeNowFrame () {\n    if (frameTime === null) {\n      frameTime = Date.now()\n      requestAnimationFrame(() => { frameTime = null })\n    }\n\n    return frameTime\n  }\n})()\n", "import { isNumeric } from '../utils/algorithms/number.utils.js'\nimport { parseISO8601, timeNowFrame } from '../utils/algorithms/time.utils.js'\n\n/** @type {FormatCall} */\nconst formatAsIs = (text) => text\n\n/** @type {Record<string, Formatter>} */\nconst baseFormatter = {\n  'as is': {\n    format: formatAsIs,\n  },\n\n  number: {\n    format: (text, locale) => Intl.NumberFormat(locale.baseName).format(Number(text)),\n  },\n\n  date: {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n      return Intl.DateTimeFormat(locale.baseName, defaultDateFormatOptions).format(date)\n    },\n  },\n\n  datetime: {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n      return Intl.DateTimeFormat(locale.baseName, defaultDateTimeFormatOptions).format(date)\n    },\n  },\n\n  timestamp: {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date(+text) : parseISO8601(text)\n      return Intl.DateTimeFormat(locale.baseName, timestampFormatOptions).format(date)\n    },\n  },\n\n  'long date': {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n      return Intl.DateTimeFormat(locale.baseName, longDateFormatOptions).format(date)\n    },\n  },\n\n  'long datetime': {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n      return Intl.DateTimeFormat(locale.baseName, longDateTimeFormatOptions).format(date)\n    },\n  },\n}\n\n/** @type {[Intl.RelativeTimeFormatUnit, number][]} */\nconst durationUnitsEntries = [\n  ['year', 1000 * 60 * 60 * 24 * 365],\n  ['month', 1000 * 60 * 60 * 24 * 365 / 12],\n  ['day', 1000 * 60 * 60 * 24],\n  ['hour', 1000 * 60 * 60],\n  ['minute', 1000 * 60],\n  ['second', 1000],\n]\n\n/** @type {Record<string, Formatter>} */\nconst baseRelativeTimeFormatter = {\n  'relative time': {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n      return relativeTimeFormat(locale, date.valueOf())\n    },\n  },\n}\n\n/** @type {Record<string, Formatter>} */\nconst relativeTimeDurationFormatter = {\n  'relative time duration': {\n    format: (text, locale) => {\n      const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n      return relativeTimeDurationFormat(locale, date.valueOf())\n    },\n  },\n}\n\n/** @type {Record<string, Formatter>} */\nconst baseInUnitRelativeTimeFormatter = Object.fromEntries(\n  durationUnitsEntries.map(([unit]) => {\n    return [`in ${unit}s`, {\n      format: (text, locale) => {\n        const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n        return relativeTimeFormatInUnit(locale, unit, date.valueOf())\n      },\n    }]\n  }),\n)\n\n/** @type {Record<string, Formatter>} */\nconst baseDurationInUnitRelativeTimeFormatter = Object.fromEntries(\n  durationUnitsEntries.map(([unit]) => {\n    return [`in ${unit}s`, {\n      format: (text, locale) => {\n        const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n        return relativeTimeDurationFormatInUnit(locale, unit, date.valueOf())\n      },\n    }]\n  }),\n)\n\n/** @type {Record<string, Formatter>} */\nconst baseToUnitRelativeTimeFormatter = Object.fromEntries(\n  durationUnitsEntries.map(([unit, duration]) => {\n    return [`to ${unit}s`, {\n      format: (text, locale) => {\n        const date = isNumeric(text) ? new Date((+text) * 1000) : parseISO8601(text)\n        return relativeTimeFormatToUnit(locale, unit, date.valueOf())\n      },\n    }]\n  }),\n)\n\nconst relativeTimeFormatters = (() => {\n  const result = {\n    ...baseRelativeTimeFormatter,\n    ...relativeTimeDurationFormatter,\n  }\n\n  for (const [baseKey] of Object.entries(baseRelativeTimeFormatter)) {\n    for (const [unitPostfix, unitParams] of Object.entries(baseInUnitRelativeTimeFormatter)) {\n      result[`${baseKey} ${unitPostfix}`] = unitParams\n    }\n  }\n\n  for (const [baseKey] of Object.entries(relativeTimeDurationFormatter)) {\n    for (const [unitPostfix, unitParams] of Object.entries(baseDurationInUnitRelativeTimeFormatter)) {\n      result[`${baseKey} ${unitPostfix}`] = unitParams\n    }\n    for (const [unitPostfix, unitParams] of Object.entries(baseToUnitRelativeTimeFormatter)) {\n      result[`${baseKey} ${unitPostfix}`] = unitParams\n    }\n  }\n\n  return result\n})()\n\n/** @type {Intl.DateTimeFormatOptions} */\nconst defaultDateTimeFormatOptions = {\n  dateStyle: 'short',\n  timeStyle: 'medium',\n}\n\n/** @type {Intl.DateTimeFormatOptions} */\nconst defaultDateFormatOptions = {\n  dateStyle: 'short',\n}\n\n/** @type {Intl.DateTimeFormatOptions} */\nconst timestampFormatOptions = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: 'numeric',\n  second: 'numeric',\n  fractionalSecondDigits: 3,\n  hour12: false,\n}\n\n/** @type {Intl.DateTimeFormatOptions} */\nconst longDateFormatOptions = {\n  dateStyle: 'long',\n}\n\n/** @type {Intl.DateTimeFormatOptions} */\nconst longDateTimeFormatOptions = {\n  dateStyle: 'long',\n  timeStyle: 'long',\n}\n\n/**\n * Shows relative time based on locale\n *\n * @param {Intl.Locale} locale\n * @param {number} d1 target timestamp\n * @param {number} d2 timestamp to compare, if not defined uses current time\n * @returns {string} formatted relative time\n */\nfunction relativeTimeFormat (locale, d1, d2 = timeNowFrame()) {\n  const elapsed = d1 - d2\n  const formatter = new Intl.RelativeTimeFormat(locale.baseName, { numeric: 'auto' })\n\n  for (const [unit, duration] of durationUnitsEntries) {\n    // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n    if (Math.abs(elapsed) > duration) {\n      return formatter.format(Math.floor(elapsed / duration), unit)\n    }\n  }\n  return formatter.format(0, 'seconds')\n}\n\n/**\n * Shows relative time based on locale, without any time adverbs such as \"ago\" (2 minutes ago), \"in\" (in 5 minutes), tomorrow, yesterday, etc\n *\n * @param {Intl.Locale} locale\n * @param {number} d1 target timestamp\n * @param {number} d2 timestamp to compare, if not defined uses current time\n * @returns {string} formatted relative time\n */\nfunction relativeTimeDurationFormat (locale, d1, d2 = timeNowFrame()) {\n  // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n  const elapsed = Math.abs(d1 - d2)\n\n  for (const [unit, duration] of durationUnitsEntries) {\n    // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n    if (elapsed > duration) {\n      return Intl.NumberFormat(locale.baseName, { style: 'unit', unit, unitDisplay: 'long' }).format(Math.floor(elapsed / duration))\n    }\n  }\n  return Intl.NumberFormat(locale.baseName, { style: 'unit', unit: 'seconds', unitDisplay: 'long' }).format(0)\n}\n\n/**\n * Shows relative time based on locale in units\n *\n * @param {Intl.Locale} locale\n * @param {number} d1 target timestamp\n * @param {number} d2 timestamp to compare, if not defined uses current time\n * @param {Intl.RelativeTimeFormatUnit} unit unit to use on the calc\n * @returns {string} formatted relative time\n */\nfunction relativeTimeFormatInUnit (locale, unit, d1, d2 = timeNowFrame()) {\n  const elapsed = d1 - d2\n  const formatter = new Intl.RelativeTimeFormat(locale.baseName, { numeric: 'auto' })\n\n  for (const [durationUnit, duration] of durationUnitsEntries) {\n    // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n    if (durationUnit === unit) {\n      return formatter.format(Math.floor(elapsed / duration), unit)\n    }\n  }\n  return relativeTimeFormat(locale, d1, d2)\n}\n\n/**\n * Shows relative time based on locale in units, without any time adverbs such as \"ago\" (2 minutes ago), \"in\" (in 5 minutes), tomorrow, yesterday, etc...\n *\n *  When the unit is zero it applies the smaller unit to\n *\n * @param {Intl.Locale} locale\n * @param {number} d1 target timestamp\n * @param {number} d2 timestamp to compare, if not defined uses current time\n * @param {Intl.RelativeTimeFormatUnit} unit unit to use on the calc\n * @returns {string} formatted relative time\n */\nfunction relativeTimeDurationFormatInUnit (locale, unit, d1, d2 = timeNowFrame()) {\n  // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n  const elapsed = Math.abs(d1 - d2)\n\n  for (const [durationUnit, duration] of durationUnitsEntries) {\n    if (durationUnit === unit) {\n      if (elapsed < duration) { break }\n      return Intl.NumberFormat(locale.baseName, { style: 'unit', unit, unitDisplay: 'long' }).format(Math.floor(elapsed / duration))\n    }\n  }\n  return relativeTimeDurationFormat(locale, d1, d2)\n}\n\n/**\n * Shows relative time based on locale, from the longest unit that has a positive value to the selected unit, without any time adverbs such as \"ago\" (2 minutes ago), \"in\" (in 5 minutes), tomorrow, yesterday, etc\n *\n * @param {Intl.Locale} locale\n * @param {number} d1 target timestamp\n * @param {number} d2 timestamp to compare, if not defined uses current time\n * @param {Intl.RelativeTimeFormatUnit} toUnit unit to use on the calc\n * @returns {string} formatted relative time\n */\nfunction relativeTimeFormatToUnit (locale, toUnit, d1, d2 = timeNowFrame()) {\n  // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n  let elapsed = Math.abs(d1 - d2)\n  const listFormatter = new Intl.ListFormat(locale.baseName, { style: 'long', type: 'conjunction' })\n\n  /** @param {string} unit */\n  const timeUnitFormatter = (unit) => Intl.NumberFormat(locale.baseName, { style: 'unit', unit, unitDisplay: 'long' })\n  const list = []\n\n  for (const [unit, duration] of durationUnitsEntries) {\n    if (elapsed > duration) {\n      const amount = Math.floor(elapsed / duration)\n      list.push(timeUnitFormatter(unit).format(amount))\n      elapsed -= amount * duration\n    }\n    if (unit === toUnit) {\n      if (list.length) {\n        break\n      }\n      return relativeTimeDurationFormat(locale, d1, d2)\n    }\n  }\n  return listFormatter.format(list)\n}\n\n/**\n * @typedef {Record<string, Formatter>} FormatterMap\n */\n\n/**\n * @callback FormatCall\n * @param {string}       text   - text input\n * @param {Intl.Locale}  locale - internationalization locale\n * @returns {string}     fomatted text\n */\n\n/**\n * @typedef {object} Formatter\n * @property {FormatCall} format\n * @property {boolean} [isconstant]\n */\n\nexport const formatters = {\n  ...baseFormatter,\n  ...relativeTimeFormatters,\n}\n", "import { isNumeric } from '../utils/algorithms/number.utils.js'\nimport { parseISO8601, timeNowFrame } from '../utils/algorithms/time.utils.js'\nimport { formatters } from './expression-formatters.js'\n\nconst defaultFormat = formatters['as is'].format\n\n/** @type {CaptureExpressionMap} */\nconst baseCapureExpressions = {\n  number: {\n    value: 400,\n    matchPredicate: () => (text) => isNumeric(text),\n    defaultFormat: formatters.number.format,\n    isConstant: true,\n  },\n\n  string: {\n    value: 300,\n    matchPredicate: () => (text) =>\n      (text.startsWith('\"') && text.endsWith('\"')) ||\n      (text.startsWith('\\'') && text.endsWith('\\'')) ||\n      (text.startsWith('`') && text.endsWith('`')),\n    defaultFormat,\n    isConstant: true,\n  },\n}\n\n/** @type {CaptureExpressionMap} */\nconst specialCapureExpressions = {\n  string: {\n    value: 1 << 20,\n    matchPredicate: (match) => (text) => match === text,\n    defaultFormat,\n    isConstant: true,\n  },\n\n  regex: {\n    value: 200,\n    matchPredicate: (regexPattern) => {\n      const regex = new RegExp(regexPattern)\n      return (text) => regex.test(text)\n    },\n    defaultFormat,\n    isConstant: true,\n  },\n\n  any: {\n    value: 100,\n    matchPredicate: () => () => true,\n    defaultFormat,\n    isConstant: true,\n  },\n}\n\n/** @type {CaptureExpressionMap} */\nconst baseTimeCaptureExpressions = {\n  // normal times\n  'unix timestamp': {\n    value: 550,\n    matchPredicate: () => (text) => isNumeric(text),\n    defaultFormat: formatters.datetime.format,\n    isConstant: false,\n  },\n\n  'iso 8601': {\n    value: 550,\n    matchPredicate: () => (text) => !isNaN(parseISO8601(text)),\n    defaultFormat: formatters.datetime.format,\n    isConstant: false,\n  },\n\n  date: {\n    value: 500,\n    matchPredicate: () => (text) => isNumeric(text) || !isNaN(parseISO8601(text)),\n    defaultFormat: formatters.datetime.format,\n    isConstant: false,\n  },\n\n  'unix millis': {\n    value: 550,\n    matchPredicate: () => (text) => isNumeric(text),\n    defaultFormat: formatters.timestamp.format,\n    isConstant: false,\n  },\n}\n/** @type {Record<string, RelativeTimeCaptureExpresionPrefix>} */\nconst relativeTimeCaptureExpresionPrefix = {\n  past: {\n    additionalvalue: 50,\n    defaultMatchPredicate: (prev) => () => {\n      const predicate = prev()\n      return (text) => predicate(text) && timeIntervalCaptureExpresionPrefix.millisecond.currentTimeCompare(text) <= 0\n    },\n  },\n\n  present: {\n    additionalvalue: 100,\n    defaultMatchPredicate: (prev) => () => {\n      const predicate = prev()\n      return (text) => predicate(text) && timeIntervalCaptureExpresionPrefix.second.currentTimeCompare(text) === 0\n    },\n  },\n\n  future: {\n    additionalvalue: 50,\n    defaultMatchPredicate: (prev) => () => {\n      const predicate = prev()\n      return (text) => predicate(text) && timeIntervalCaptureExpresionPrefix.millisecond.currentTimeCompare(text) > 0\n    },\n  },\n}\n\n/** @type {Record<string, TimeIntervalCaptureExpresionPrefix>} */\nconst timeIntervalCaptureExpresionPrefix = {\n  millisecond: {\n    additionalvalue: 33,\n    currentTimeCompare: (text) => {\n      const timeText = isNumeric(text) ? new Date((+text) * 1000).valueOf() : parseISO8601(text)\n      const timeNow = timeNowFrame()\n      return timeText - timeNow\n    },\n  },\n\n  second: {\n    additionalvalue: 30,\n    currentTimeCompare: (text) => {\n      const timeText = isNumeric(text) ? new Date((+text) * 1000).valueOf() : parseISO8601(text)\n      const timeNow = timeNowFrame()\n      return Math.floor(timeText / 1000) - Math.floor(timeNow / 1000)\n    },\n  },\n\n  minute: {\n    additionalvalue: 29,\n    currentTimeCompare: (text) => {\n      const timeText = isNumeric(text) ? new Date((+text) * 1000).valueOf() : parseISO8601(text)\n      const timeNow = timeNowFrame()\n      return Math.floor(timeText / 60_000) - Math.floor(timeNow / 60_000)\n    },\n  },\n\n  hour: {\n    additionalvalue: 28,\n    currentTimeCompare: (text) => {\n      const timeText = isNumeric(text) ? new Date((+text) * 1000).valueOf() : parseISO8601(text)\n      const timeNow = timeNowFrame()\n      return Math.floor(timeText / 360_000) - Math.floor(timeNow / 360_000)\n    },\n  },\n\n  day: {\n    additionalvalue: 27,\n    currentTimeCompare: (text) => {\n      const timeText = isNumeric(text) ? new Date((+text) * 1000).valueOf() : parseISO8601(text)\n      const timeNow = timeNowFrame()\n      return Math.floor(timeText / 86_400_000) - Math.floor(timeNow / 86_400_000)\n    },\n  },\n\n  week: {\n    additionalvalue: 26,\n    currentTimeCompare: (text) => {\n      const date = new Date(isNumeric(text) ? (+text) * 1000 : parseISO8601(text))\n      const dateNow = new Date(timeNowFrame())\n      const yearNow = dateNow.getFullYear()\n      const yeardiff = date.getFullYear() - yearNow\n      if (yeardiff !== 0) { return yeardiff }\n      const onejan = new Date(yearNow, 0, 1)\n      const onejanDay = onejan.getDay()\n      const onejanTimeStamp = onejan.valueOf()\n      const weekNow = Math.ceil((((dateNow.valueOf() - onejanTimeStamp) / 86400000) + onejanDay + 1) / 7)\n      const week = Math.ceil((((date.valueOf() - onejanTimeStamp) / 86400000) + onejanDay + 1) / 7)\n      return week - weekNow\n    },\n\n  },\n\n  month: {\n    additionalvalue: 25,\n    currentTimeCompare: (text) => {\n      const date = new Date(isNumeric(text) ? (+text) * 1000 : parseISO8601(text))\n      const dateNow = new Date(timeNowFrame())\n      return date.getFullYear() * 12 + date.getMonth() - dateNow.getFullYear() * 12 + dateNow.getMonth()\n    },\n  },\n\n  year: {\n    additionalvalue: 24,\n    currentTimeCompare: (text) => {\n      const date = new Date(isNumeric(text) ? (+text) * 1000 : parseISO8601(text))\n      const dateNow = new Date(timeNowFrame())\n      return date.getFullYear() - dateNow.getFullYear()\n    },\n\n  },\n}\n\n/**\n *\n * @returns {CaptureExpressionMap}\n */\nfunction buildTimeCaptureExpressions () {\n  const { entries, fromEntries } = Object\n  return fromEntries(entries(baseTimeCaptureExpressions).flatMap(([baseKey, baseInfo]) => {\n    const result = [[baseKey, baseInfo]]\n    for (const [relativePrefixKey, relativePrefixInfo] of entries(relativeTimeCaptureExpresionPrefix)) {\n      const infoWithRelTime = {\n        ...baseInfo,\n        value: baseInfo.value + relativePrefixInfo.additionalvalue,\n        matchPredicate: relativePrefixInfo.defaultMatchPredicate(baseInfo.matchPredicate),\n      }\n      result.push([\n        `${relativePrefixKey} ${baseKey}`,\n        infoWithRelTime,\n      ])\n      for (const [intervalKey, intervalnfo] of entries(timeIntervalCaptureExpresionPrefix)) {\n        result.push([\n          `${relativePrefixKey} ${intervalKey} ${baseKey}`, {\n            ...infoWithRelTime,\n            value: infoWithRelTime.value + intervalnfo.additionalvalue,\n          }])\n      }\n    }\n\n    return result\n  }))\n}\n\nexport const captureExpressions = {\n  special: specialCapureExpressions,\n  named: {\n    ...baseCapureExpressions,\n    ...buildTimeCaptureExpressions(),\n  },\n}\n\n/** @typedef {Record<string, CaptureExpressionInfo>} CaptureExpressionMap */\n\n/**\n * @typedef {object} CaptureExpressionInfo\n *\n * Capture expression information used by key parser, as to get the correct matcher\n * based on the ket priority.\n *\n * @property {number}                value - Prioriy value of the capture expression, the higher value, the key is used when conflicting keys are found.\n * @property {MatchPredicateCreator} matchPredicate - Match predicate creator. The resulting match predicate is based on the `parameters` used\n *                                                    (e.g. creating a matcher from a regex pattern).\n * @property {FormatCall}            defaultFormat - Default format to be used when no formatter is explicitly applied.\n * @property {boolean}               isConstant - A flag to indicate whether the matcher will always match the same key in a translation map,\n *                                                It helps to decide when to query the translation map for the same key.\n *\n */\n\n/** @typedef {import('./expression-formatters.js').FormatCall} FormatCall */\n/** @typedef {(text: string) => boolean} MatchPredicate */\n/** @typedef {(...parameters: string[]) => MatchPredicate} MatchPredicateCreator */\n\n/**\n * @typedef {object} TimeIntervalCaptureExpresionPrefix\n *\n * @property {number}                additionalvalue - Additional Prioriy value of the capture expression, the higher value, the key is used when conflicting keys are found.\n * @property {(timeStr: string) => number} currentTimeCompare - compare text formatted date to current time. returns negative number when `timeStr` is in the past, positive in the future, 0 in the present\n */\n\n/**\n * @typedef {object} RelativeTimeCaptureExpresionPrefix\n *\n * @property {number}                additionalvalue - Additional Prioriy value of the capture expression, the higher value, the key is used when conflicting keys are found.\n * @property {(prev: MatchPredicateCreator) => MatchPredicateCreator} defaultMatchPredicate - predicate to use when no no time unit is defined (e.g. present **day** date).\n */\n", "/**\n * @file responsible of calculating key priority in key\n */\n\nimport { states } from './key-ast.util.js'\nimport { captureExpressions } from './capture-expression-values.js'\n\n/**\n * @param {import('./key-ast.util.js').AST} ast\n * @returns\n */\nexport function calculatePriority (ast) {\n  return calculatePriorityFromTokens(ast.tokens)\n}\n\n/**\n * @param {import('./key-ast.util.js').Token[]} tokens\n * @returns {KeyPriority}\n */\nfunction calculatePriorityFromTokens (tokens) {\n  const captureTokens = tokens.filter((token) => token.type === states.capture)\n  const captureValues = captureTokens.length\n  const captureExpressionsInfo = captureTokens.map(calculateCaptureTokenPriority)\n  const sum = captureExpressionsInfo.reduce((a, b) => a + b, 0)\n  return {\n    priority: [captureValues, sum],\n    priorityAsNumber: getNumericValuePriority(captureValues, sum),\n  }\n}\n\n/**\n * Calculates the priority of a value token\n * @param {import('./key-ast.util.js').Token} captureToken\n * @returns\n */\nfunction calculateCaptureTokenPriority (captureToken) {\n  if (captureToken.childTokens.length === 0) {\n    return captureExpressions.special.any.value\n  }\n\n  let value = Number.MAX_SAFE_INTEGER\n  let currentExpression = ''\n  for (const token of captureToken.childTokens) {\n    switch (token.type) {\n      case states.capture_expr:\n        currentExpression = currentExpression ? `${currentExpression} ${token.text}` : token.text\n        continue\n      case states.capture_expr_sep:\n        value = Math.min(value, captureExpressions.named[currentExpression]?.value ?? 0)\n        currentExpression = ''\n        continue\n      case states.regex:\n        value = Math.min(value, captureExpressions.special.regex.value)\n        continue\n      case states.sq_string:\n      case states.dq_string:\n      case states.bt_string:\n        value = Math.min(value, captureExpressions.named.string.value)\n        continue\n    }\n  }\n\n  if (currentExpression) {\n    value = Math.min(value, captureExpressions.named[currentExpression]?.value ?? 0)\n  }\n\n  return value\n}\n\n/**\n * Calculates the priority into a numeric value to ease comparison of keys priority\n *\n * @param {number} captures - first value of priority - the number of capture tokens\n * @param {number} sum      - second value of priority - the sum of capture token values\n * @returns the numeric representation of priority tuple\n */\nexport const getNumericValuePriority = (captures, sum) => Number.MAX_SAFE_INTEGER - (captures << 20) + sum\n\n/**\n * @typedef {object} KeyPriority\n *\n * @property {[number, number]} priority\n * @property {number} priorityAsNumber\n *\n */\n", "/**\n * Escape regex pattern as to search for raw string, similar to Perl's \\Q ... \\E and quotemeta\n *\n * @param {string} pattern\n * @returns {string} escaped regex pattern\n */\nexport function escape (pattern) {\n  return String(pattern).replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n", "import { states } from './key-ast.util.js'\nimport { escape } from '../utils/algorithms/regex.utils.js'\nimport { captureExpressions } from './capture-expression-values.js'\n\nconst falsePredicate = () => false\n/** @type {readonly []} */\nconst emptyArray = Object.freeze([])\n\n/** @type {ParameterMatchResult} */\nconst anyMatchExpression = Object.freeze({\n  isMatch: true,\n  expressionInfo: captureExpressions.special.any,\n})\n\nconst noMatchExpression = Object.freeze({\n  isMatch: false,\n})\n\nconst anyMatchCaptureExpressionsInfo = {\n  matchPredicate: () => anyMatchExpression,\n}\n\n/** @type {MatchResult} */\nconst noMatch = Object.freeze({\n  isMatch: false,\n  parameters: emptyArray,\n  defaultFormatters: emptyArray,\n})\n\n/** @type {MatchResult} */\nconst emptyYesMatch = Object.freeze({\n  isMatch: true,\n  parameters: emptyArray,\n  defaultFormatters: emptyArray,\n})\n\n/**\n * @param {string} textToMatch\n * @returns {Matcher}\n */\nconst exactStringMatcher = (textToMatch) => (text) => (textToMatch === text) ? emptyYesMatch : noMatch\n\n/**\n *\n * @param {import('./key-ast.util.js').Token[]} tokens\n * @returns {Matcher}\n */\nfunction getMatcherFromTokens (tokens) {\n  const captureTokens = tokens.filter((token) => token.type === states.capture)\n\n  if (captureTokens.length <= 0) {\n    const textToMatch = tokens.map((token) => token.text).join('')\n    return exactStringMatcher(textToMatch)\n  }\n\n  const captureExpressionsInfo = captureTokens.map((captureToken) => {\n    /** @type {CaptureExpressionsInfoDetail[]} */\n    const fragmentedCaptureExpressionsInfo = []\n    if (captureToken.childTokens.length === 0) {\n      return anyMatchCaptureExpressionsInfo\n    }\n    let currentExpression = ''\n    for (const token of captureToken.childTokens) {\n      switch (token.type) {\n        case states.capture_expr:\n          currentExpression = currentExpression ? `${currentExpression} ${token.text}` : token.text\n          continue\n\n        case states.capture_expr_sep:\n          fragmentedCaptureExpressionsInfo.push({\n            type: 'expression',\n            text: currentExpression,\n            expressionInfo: captureExpressions.named[currentExpression],\n            matches: captureExpressions.named[currentExpression]?.matchPredicate() ?? falsePredicate,\n          })\n          currentExpression = ''\n          continue\n        case states.regex:\n          fragmentedCaptureExpressionsInfo.push({\n            type: 'regex',\n            text: token.text,\n            expressionInfo: captureExpressions.special.regex,\n            matches: captureExpressions.special.regex.matchPredicate(token.text.slice(1, -1)),\n          })\n          continue\n        case states.sq_string:\n        case states.dq_string:\n        case states.bt_string:\n          fragmentedCaptureExpressionsInfo.push({\n            type: 'string',\n            text: token.text,\n            expressionInfo: captureExpressions.special.string,\n            matches: captureExpressions.special.string.matchPredicate(token.text),\n          })\n          continue\n      }\n    }\n    if (currentExpression) {\n      fragmentedCaptureExpressionsInfo.push({\n        type: 'expression',\n        text: currentExpression,\n        expressionInfo: captureExpressions.named[currentExpression],\n        matches: captureExpressions.named[currentExpression]?.matchPredicate() ?? falsePredicate,\n      })\n    }\n\n    return {\n      /**\n       *\n       * @param {string} text\n       * @returns {ParameterMatchResult}\n       */\n      matchPredicate: (text) => {\n        const expressionPart = fragmentedCaptureExpressionsInfo.find((expressionPart) => expressionPart.matches(text))\n        if (!expressionPart) {\n          return noMatchExpression\n        }\n        return {\n          isMatch: true,\n          expressionInfo: expressionPart.expressionInfo,\n        }\n      },\n    }\n  })\n\n  const regexStr = tokens.map((token) => {\n    if (token.type === states.capture) {\n      return '(.*)'\n    } else {\n      return escape(token.text)\n    }\n  }).join('')\n\n  const regex = new RegExp('^' + regexStr + '$')\n\n  return (text) => {\n    if (typeof text !== 'string') return noMatch\n    const matches = text.match(regex)\n    if (matches == null) {\n      return noMatch\n    }\n\n    const parameters = matches.slice(1)\n    const paramMatchInfo = []\n\n    for (const [index, text] of parameters.entries()) {\n      const matchResult = captureExpressionsInfo[index].matchPredicate(text)\n      if (!matchResult.isMatch) {\n        return noMatch\n      }\n      paramMatchInfo.push(matchResult.expressionInfo)\n    }\n\n    const defaultFormatters = paramMatchInfo.map((info) => info.defaultFormat)\n\n    return {\n      isMatch: true,\n      parameters,\n      defaultFormatters,\n    }\n  }\n}\n\n/**\n *\n * @param {import('./key-ast.util.js').AST} ast\n * @returns {Matcher}\n */\nexport function getMatcher (ast) {\n  return getMatcherFromTokens(ast.tokens)\n}\n\n/**\n * @typedef {object} CaptureExpressionsInfoDetail\n * @property {'expression' | 'regex' | 'string' | 'any'} type\n * @property {string} text\n * @property {import('./capture-expression-values.js').CaptureExpressionInfo} expressionInfo\n * @property {(text: string) => boolean} matches\n */\n\n/**\n * @typedef {(text: string, locale: Intl.Locale) => string} Formatter\n */\n\n/**\n * @typedef {Readonly<{ isMatch: false } | {isMatch: true, expressionInfo: import('./capture-expression-values.js').CaptureExpressionInfo}>} ParameterMatchResult\n */\n\n/**\n * @typedef {(text: string) => MatchResult} Matcher\n */\n\n/**\n * @typedef {object} MatchResult\n * @property {boolean} isMatch\n * @property {readonly string[]} parameters\n * @property {readonly Formatter[]} defaultFormatters\n */\n", "import { getAST, states } from './key-ast.util.js'\nimport { calculatePriority } from './priority-calculator.js'\nimport { getMatcher } from './template-matcher.js'\n\n/** @param {Token} token - parsed key AST */\nfunction normalizeDefaultToken (token) {\n  return token.text\n}\n\n/**\n * @param {Token} token - parsed key AST\n * @returns {string}\n */\nfunction normalizedCaptureToken (token) {\n  const { childTokens } = token\n\n  if (childTokens.length <= 0) {\n    return '{}'\n  }\n  let normalizedCapture = normalizeToken(childTokens[0])\n  for (let i = 1, e = childTokens.length; i < e; i++) {\n    const previousToken = childTokens[i - 1]\n    const token = childTokens[i]\n    if (previousToken.type === states.capture_expr && token.type === states.capture_expr) {\n      normalizedCapture += ' '\n    }\n    normalizedCapture += normalizeToken(token)\n  }\n  return `{${normalizedCapture}}`\n}\n\nconst normalizeTokenMapper = {\n  [states.capture]: normalizedCaptureToken,\n  [states.normal]: normalizeDefaultToken,\n}\n\n/**\n * Uses the target abstract syntax tree token to normalize the key\n * @param {Token} token - parsed key AST\n */\nfunction normalizeToken (token) {\n  return (normalizeTokenMapper[token.type] ?? normalizeDefaultToken)(token)\n}\n\n/**\n * Uses the abstract syntax tree to normalize the key\n * @param {AST} ast - parsed key AST\n */\nfunction getNormalizedKey (ast) {\n  return ast.tokens.map(normalizeToken).join('')\n}\n\n/**\n * Parses i18n key\n *\n * @param {string} key - target key to parse\n * @returns {ParseResult} - parse result\n */\nexport function parseKey (key) {\n  const ast = getAST(key)\n  const { priority, priorityAsNumber } = calculatePriority(ast)\n  const match = getMatcher(ast)\n  const normalizedKey = getNormalizedKey(ast)\n\n  return {\n    priority,\n    priorityAsNumber,\n    key,\n    ast,\n    match,\n    normalizedKey,\n    matches: (text) => match(text).isMatch,\n  }\n}\n\n/// types\n\n/**\n * @typedef {object} ParseResult\n *\n * Representes the result of parsing a defined key\n *\n * @property {[number, number]} priority\n *   Defines the key priority.\n *\n *   When finding conflicting keys the one with the hightes priority is choosen\n *\n *   The priority is defined by specificity, the more specific, the highest\n *   priority it has.\n *\n *   The specificy is defined by 2 factors:\n *   - the lesser number of parameter\n *   - the specificity of each parameter\n *\n *   That is what those 2 values means in the priority key, the first value is\n *   the number of parameters in the key, and the sum of each parameter specificity value\n * @property {number} priorityAsNumber\n *   `ParseResult.priority` represented value as a number, to simplify comparing keys priorities, see {@link ParseResult.priority}\n * @property {string} key - target key used to parse\n * @property {string} normalizedKey - normalized target key used to parse\n * @property {MatchPredicate} matches - Predicate to check if a defined text matches the key\n * @property {ReturnType<typeof getMatcher>} match - matcher of target key\n * @property {AST} ast - Abstract syntax tree generated as result from parsing the key\n */\n\n/**\n * @callback MatchPredicate\n *\n * Predicate to check if a defined text matches the key\n *\n * @param {string} text - target text to parse\n * @returns {boolean}\n */\n\n/** @typedef {import('./key-ast.util.js').Token} Token */\n/** @typedef {import('./key-ast.util.js').AST} AST */\n", "import { states } from './key-ast.util.js'\nimport { formatters as expressionFormatters } from './expression-formatters.js'\nimport { isInteger } from '../utils/algorithms/number.utils.js'\n\n/** @type {readonly never[]} */\nconst emptyArray = Object.freeze([])\n\n/**\n * Add or replace format method from templateFormatter object\n *\n * @param {Omit<TemplateFormatter, 'format'>} templateFormatter\n * @returns {TemplateFormatter}\n */\nconst formatterWithFormat = (templateFormatter) => ({\n  ...templateFormatter,\n  format: (parameters, locale, defaultFormatters) => {\n    const { strings, formatters } = templateFormatter\n    let result = strings[0]\n    for (let i = 1, e = strings.length; i < e; ++i) {\n      result += formatters[i - 1](parameters, locale, defaultFormatters) + strings[i]\n    }\n    return result\n  },\n})\n\n/**\n * Returns a formatter that returns the `value` content\n *\n * Used when the value does not have parameters\n *\n * @param {string} value\n * @returns {TemplateFormatter}\n */\nconst formatSimpleKey = (value) => ({\n  strings: [value],\n  formatters: emptyArray,\n  format: () => value,\n})\n\n/**\n * Parse capture key to ease usage in {@link getFormatterFromTokens}\n * @param {Token} captureToken\n * @returns {CaptureExpressionsInfoDetail[]}\n */\nfunction parseCaptureKey (captureToken) {\n  /** @type {CaptureExpressionsInfoDetail[]} */\n  const fragmentedCaptureExpressionsInfo = []\n\n  let currentExpression = ''\n  for (const token of captureToken.childTokens) {\n    switch (token.type) {\n      case states.capture_expr:\n        currentExpression = currentExpression ? `${currentExpression} ${token.text}` : token.text\n        continue\n\n      case states.capture_expr_sep:\n        fragmentedCaptureExpressionsInfo.push({\n          type: 'expression',\n          text: currentExpression,\n        })\n        currentExpression = ''\n        continue\n      case states.sq_string:\n      case states.dq_string:\n      case states.bt_string:\n        fragmentedCaptureExpressionsInfo.push({\n          type: 'string',\n          text: token.text.slice(1, token.text.length - 1),\n        })\n        continue\n      default:\n        console.error('error: invalid expression, ignoring...')\n    }\n  }\n  if (currentExpression) {\n    fragmentedCaptureExpressionsInfo.push({\n      type: 'expression',\n      text: currentExpression,\n    })\n  }\n\n  return fragmentedCaptureExpressionsInfo\n}\n\n/**\n * Formatter to use for simple capture expressions (e.g. `{0}`)\n * @type {FormatterReducer}\n */\nfunction applyDefaultformatter (acc) {\n  if (acc.defaultFormatters && typeof acc.position === 'number') {\n    return {\n      ...acc,\n      result: acc.defaultFormatters[acc.position](acc.result, acc.locale),\n    }\n  }\n  return acc\n}\n\n/**\n *\n * @param {number} position\n * @returns {FormatterReducer}\n */\nconst positionFormatter = (position) => (acc) => {\n  const { parameters } = acc\n  if (parameters.length <= position) {\n    return {\n      ...acc,\n      result: '',\n      exit: true,\n    }\n  }\n  return {\n    ...acc,\n    position,\n    result: parameters[position],\n  }\n}\n\n/**\n *\n * @param {FormatterReducer[]} fragmentedFormatters\n * @param {readonly string[]} parameters\n * @param {Intl.Locale} locale\n * @param {readonly DefaultFormatter[]} [defaultFormatters]\n * @returns\n */\nconst reducerFormatter = (fragmentedFormatters, parameters, locale, defaultFormatters = []) => {\n  /** @type {FormatterReducerAcc} */\n  let reducerAcc = {\n    parameters,\n    defaultFormatters,\n    result: '',\n    locale,\n  }\n  for (const fragmentedFormatter of fragmentedFormatters) {\n    if (reducerAcc.exit) {\n      return reducerAcc.result\n    }\n    reducerAcc = fragmentedFormatter(reducerAcc)\n  }\n  return reducerAcc.result\n}\n\n/**\n *\n * @param {Token[]} tokens\n * @returns\n */\nfunction getFormatterFromTokens (tokens) {\n  const captureTokens = tokens.filter((token) => token.type === states.capture)\n\n  if (captureTokens.length <= 0) {\n    const textToMatch = tokens.map((token) => token.text).join('')\n    return formatSimpleKey(textToMatch)\n  }\n\n  /** @type {string[]} */\n  const strings = []\n  /** @type {Formatter[]} */\n  const formatters = []\n\n  for (const keyToken of tokens) {\n    if (keyToken.type !== states.capture) {\n      strings.push(keyToken.text)\n      continue\n    }\n    const fragmentedCaptureExpressionsInfo = parseCaptureKey(keyToken)\n\n    if (fragmentedCaptureExpressionsInfo.length === 0) {\n      formatters.push(() => '')\n      continue\n    }\n\n    /** @type {FormatterReducer[]} */\n    const fragmentedFormatters = []\n\n    const [firstInfo, ...restInfo] = fragmentedCaptureExpressionsInfo\n\n    if (firstInfo.type === 'string') {\n      const { text } = firstInfo\n      fragmentedFormatters.push((acc) => ({ ...acc, result: text }))\n    } else if (isInteger(firstInfo.text)) {\n      const position = +firstInfo.text\n      fragmentedFormatters.push(positionFormatter(position))\n    } else {\n      formatters.push(() => '')\n      continue\n    }\n\n    for (const info of restInfo) {\n      const { text } = info\n      if (Object.hasOwn(expressionFormatters, text)) {\n        const formatter = expressionFormatters[text]\n        fragmentedFormatters.push((acc) => ({\n          ...acc,\n          result: formatter.format(acc.result, acc.locale),\n        }))\n      }\n    }\n\n    if (fragmentedFormatters.length <= 1) {\n      fragmentedFormatters.push(applyDefaultformatter)\n    }\n\n    formatters.push((parameters, locale, defaultFormatters) => reducerFormatter(fragmentedFormatters, parameters, locale, defaultFormatters))\n  }\n\n  /*\n    template strings format works the same way, starts with a string and ends with a string, even\n    if it ends with a parameter\n  */\n  if (strings.length === formatters.length) {\n    strings.push('')\n  }\n\n  return formatterWithFormat({ strings, formatters })\n}\n\n/**\n *\n * @param {AST} ast\n * @returns {TemplateFormatter}\n */\nexport function getFormatter (ast) {\n  return getFormatterFromTokens(ast.tokens)\n}\n\n/** @typedef {import('./key-ast.util.js').AST} AST */\n/** @typedef {import('./key-ast.util.js').Token} Token */\n/** @typedef {import('./capture-expression-values.js').CaptureExpressionInfo} CaptureExpressionInfo */\n/** @typedef {import('./capture-expression-values.js').FormatCall} DefaultFormatter */\n\n/**\n * @typedef {object} CaptureExpressionsInfoDetail\n * @property {'expression' | 'string'} type\n * @property {string} text\n */\n\n/**\n * @typedef {object} FormatterReducerAcc\n *\n * Formatter reducer accumulator, used when piping in the result with an expression (e.g. `{0 | relative time}`)\n *\n * @property {readonly string[]} parameters\n *  Parameters used in the i18n key, e.g. when translating \"On 2023-01-01T20:00:00 I bought 10 fireworks\"\n *  on key \"On {date} I bought {number} fireworks\", the parameters are going to be [\"2023-01-01T20:00:00\", \"10\"]\n * @property {readonly DefaultFormatter[]}  defaultFormatters\n *   The default formatter to use for each parameter in `parameters`\n * @property {string}       result - The current result on accumulator, is the final result after passing all reducers\n * @property {Intl.Locale}  locale - Locale used when formatting the text\n * @property {number}       [position] - index of `parameters` to match text\n * @property {boolean}      [exit] - flag to exit early and use `result` as final result immediately, ignoring the rest of the reducers\n */\n\n/**\n * @typedef {(previous: FormatterReducerAcc) => FormatterReducerAcc} FormatterReducer\n */\n\n/**\n * @typedef {(parameters: readonly string[], locale: Intl.Locale, defaultFormatters?: readonly DefaultFormatter[]) => string} Formatter\n */\n\n/**\n * @typedef {object} TemplateFormatter\n *\n *\n * @property {readonly string[]} strings\n * @property {readonly Formatter[]} formatters\n * @property {(parameters: readonly string[], locale: Intl.Locale, defaultFormatters?: readonly DefaultFormatter[]) => string} format\n */\n", "import { getAST, states } from './key-ast.util.js'\nimport { getFormatter } from './value-formatter.js'\n\nconst tokenToString = (() => {\n  /** @typedef {(token: import('./key-ast.util.js').Token) => string} TokenToString */\n\n  /** @type {TokenToString[]} */\n  const mapper = []\n  /** @type {TokenToString} */\n  const defaultMapper = (token) => token.text\n  mapper[states.normal] = defaultMapper\n  mapper[states.capture] = (token) => {\n    const { childTokens } = token\n\n    if (childTokens.length <= 0) {\n      return '{}'\n    }\n    let normalizedCapture = tokenToString(childTokens[0])\n    for (let i = 1, e = childTokens.length; i < e; i++) {\n      const previousToken = childTokens[i - 1]\n      const token = childTokens[i]\n      if (previousToken.type === states.capture_expr && token.type === states.capture_expr) {\n        normalizedCapture += ' '\n      }\n      normalizedCapture += tokenToString(token)\n    }\n    return `{${normalizedCapture}}`\n  }\n\n  /** @type {TokenToString} */\n  const tokenToString = (token) => (mapper[token.type] ?? defaultMapper)(token)\n  return tokenToString\n})()\n\n/**\n * Normalizes translation entry value, we use the AST instead of the text\n * to not parse it multiple times on {@link parseValue}\n *\n * @param {import('./key-ast.util.js').AST} ast - parsed AST of the value\n * @returns {string} normalized value\n */\nfunction getNormalizedValue (ast) {\n  return ast.tokens.map((token) => tokenToString(token)).join('')\n}\n\n/**\n * Parses I18n translation entry value\n *\n * @param {string} value - target i18n entry value\n * @returns {ParseResult} - parse result information\n */\nexport function parseValue (value) {\n  const ast = getAST(value)\n  const formatter = getFormatter(ast)\n  const normalizedValue = getNormalizedValue(ast)\n\n  return {\n    value,\n    ast,\n    formatter,\n    format: formatter.format,\n    normalizedValue,\n  }\n}\n\n/**\n * @typedef {object} ParseResult\n *\n * @property {string} value - target value used to parse\n * @property {string} normalizedValue - normalized `value`\n * @property {ReturnType<typeof getFormatter>} formatter - function to get the final output based on received key parameters\n * @property {ReturnType<typeof getFormatter>['format']} format - returns the final output based on received key parameters\n * @property {import('./key-ast.util.js').AST} ast - abstract syntax tree generated by the parser, usefull to debug\n */\n", "import { parseKey } from '../../key-parser/key-parser.util.js'\nimport { parseValue } from '../../key-parser/value-parser.util.js'\n\n/**\n * Creates an {@link OptimizedTranslations} based on target {@link Translations}\n *\n * @param {Translations} translations - target translations\n *\n * @returns {OptimizedTranslations} resulting optimized translation\n */\nfunction optimizeTranslationForQueries (translations) {\n  /** @type {OptimizedTranslations} */\n  const result = {\n    literalKeys: {},\n    templateKeys: {},\n    sortedTemplateKeys: [],\n    prefixTemplateSearchByWords: {},\n  }\n  const { literalKeys, templateKeys, sortedTemplateKeys, prefixTemplateSearchByWords } = result\n\n  for (const [key, value] of Object.entries(translations)) {\n    const parsedKey = parseKey(key)\n    if (parsedKey.priority[0] <= 0) {\n      literalKeys[key] = value\n      continue\n    }\n\n    const optimizedTemplateKey = { key, parsedKey, value }\n\n    templateKeys[key] = optimizedTemplateKey\n    sortedTemplateKeys.push(optimizedTemplateKey)\n    const prefix = parsedKey.ast.tokens[0].text\n\n    prefixTemplateSearchByWords[prefix] ||= {}\n    prefixTemplateSearchByWords[prefix][key] = value\n  }\n\n  sortedTemplateKeys.sort((a, b) => b.parsedKey.priorityAsNumber - a.parsedKey.priorityAsNumber)\n\n  return result\n}\n\n/** @type {WeakMap<Translations, TranslationQueryOptimization>} */\nconst translationOptimizations = new WeakMap()\n\n/**\n * Queries translation value from a {@link Translations} object\n *\n * @param {string}       key          - target key\n * @param {Translations} translations - target {@link Translations} object to search\n *\n * @returns {QueryResult} result of the query\n */\nexport function queryFromTranslations (key, translations) {\n  let optmization = translationOptimizations.get(translations)\n  if (!optmization) {\n    optmization = {\n      cache: {},\n      optimizedMap: optimizeTranslationForQueries(translations),\n    }\n    translationOptimizations.set(translations, optmization)\n  }\n\n  const { cache, optimizedMap } = optmization\n\n  if (cache[key] != null) {\n    return cache[key]\n  }\n\n  if (optimizedMap.literalKeys[key] != null) {\n    const valueTemplate = optimizedMap.literalKeys[key]\n    cache[key] = {\n      targetKey: key,\n      translations,\n      found: true,\n      valueTemplate,\n      translate: translatorFromValue(valueTemplate),\n    }\n    return cache[key]\n  }\n\n  const { templateKeys } = optimizedMap\n  for (const { key: templateKey } of optimizedMap.sortedTemplateKeys) {\n    const { parsedKey } = templateKeys[templateKey]\n    const match = parsedKey.match(key)\n    if (match.isMatch) {\n      const valueTemplate = templateKeys[templateKey].value\n      cache[key] = {\n        targetKey: key,\n        translations,\n        found: true,\n        valueTemplate,\n        translate: translatorFromValue(valueTemplate, match),\n      }\n      return cache[key]\n    }\n  }\n\n  return {\n    targetKey: key,\n    translations,\n    found: false,\n    valueTemplate: '',\n    translate: () => key,\n  }\n}\n\n/**\n * Gets the tranlate function from value template and match result, in case match Result is undefined\n * it will assume it came from a literal key match\n *\n * @param {string} valueTemplate target match result\n * @param {ReturnType<ReturnType<typeof parseKey>[\"match\"]>} [match] target match result\n * @returns {TranslateFunction} translate function from targetMatch\n */\nfunction translatorFromValue (valueTemplate, match) {\n  const parameters = match?.parameters ?? []\n  const defaultFormatters = match?.defaultFormatters ?? []\n  let value\n  return (locale) => {\n    value ??= parseValue(valueTemplate)\n    return value.format(parameters, locale, defaultFormatters)\n  }\n}\n\n/**\n * @typedef {string} TranslationValue\n *\n * Translation value, it is a separate type since it is expected to change.\n *\n * The current plan is in the future to chang to {\n *    value: string,\n *    kind: \"raw\" | \"template\" | \"import\" | \"import template\"\n * }\n */\n\n/**\n * @typedef {Object<string, TranslationValue>} Translations\n *\n * Translation map\n */\n\n/**\n * @typedef {object} TranslationQueryOptimization\n *\n * An object used to optimize queries from a {@link Translations} object, it is generated the fist time it is called\n * {@link queryFromTranslations} for each new {@link Translations} object\n *\n * @property {Object<string, QueryResult>}  cache        - query result cache map used for memoization\n * @property {OptimizedTranslations}        optimizedMap - optimized translation map @see OptimizedTranslations\n */\n\n/**\n * @typedef {object} QueryResult\n *\n * Result of queryFromTranslations\n *\n * @property {string}             targetKey      - key used to search translation\n * @property {Translations}       translations   - translation map used for search\n * @property {boolean}            found          - boolean that tells whether the key was found\n * @property {string}             valueTemplate  - template of found value from query, emptry string if not found\n * @property {TranslateFunction}  translate      - translate function based on locale, returns target key if not found\n */\n\n/**\n * @callback TranslateFunction\n * @param {Intl.Locale} locale - locale used to translate\n * @returns {string} translated content\n */\n\n/**\n * @typedef {object} OptimizedTranslations\n *\n *   A {@link Translations} object adapted to improve query speed\n *\n * @property {Translations}                          literalKeys                 -   It contains only non-template keys, since they have the highest\n *  priority it will be use for a quick search before searching the remaining keys, which all are template keys\n * @property {Object<string, OptimizedTemplateKey>} templateKeys   - A map of \"template key\" to \"optimized template info\" with already computed information\n * @property {OptimizedTemplateKey[]}           sortedTemplateKeys -  A list of of template keys sorted by priority\n * @property {Object<string, Translations>}    prefixTemplateSearchByWords - A map of translations by prefix, unused, @todo use it\n */\n\n/**\n * @typedef {object} OptimizedTemplateKey\n *\n * An optimized template key entry with already parsed key as to avoid parsing it again every query\n *\n * @property {string}                      key       - target translation key\n * @property {ReturnType<typeof parseKey>} parsedKey - parsed target translation key information for faster matches\n * @property {string}                      value     - respective value of Tranlation key\n */\n", "// @ts-check\n/**\n *   A strictier sanitizer that allows only text related tags and attributes as to allow any sort of content formatting,\n * makes no sense to use pictures or forms as html content in i18n, you translate mostly text, so you use data-i18n on the\n * form elements instead of using html as translation value.\n */\n\n/**\n * A set of allowed tags for the sanitizer decide whether to remove an element or not\n * Any element where its tag name is absent on the set is to be removed\n */\nexport const ALLOWED_TAGS = new Set([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'br',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'decorator',\n  'del',\n  'details',\n  'dfn',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'element',\n  'em',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'i',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'meter',\n  'nav',\n  'nobr',\n  'ol',\n  'p',\n  'pre',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'section',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'time',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'wbr',\n])\n\n/**\n *   A set of allowed attribute for the sanitizer decide whether to remove an attribute from an element or not.\n *   Any attribute where its name is absent on the set is to be removed except data-* attribute not related to i18n,\n *  and aria-* attributes\n */\nexport const ALLOWED_STANDARD_ATTRS = new Set([\n  'accept',\n  'action',\n  'align',\n  'alt',\n  'autocapitalize',\n  'autocomplete',\n  'autopictureinpicture',\n  'autoplay',\n  'background',\n  'bgcolor',\n  'border',\n  'capture',\n  'cellpadding',\n  'cellspacing',\n  'checked',\n  'cite',\n  'class',\n  'clear',\n  'color',\n  'cols',\n  'colspan',\n  'controls',\n  'controlslist',\n  'coords',\n  'crossorigin',\n  'datetime',\n  'decoding',\n  'default',\n  'dir',\n  'disabled',\n  'disablepictureinpicture',\n  'disableremoteplayback',\n  'download',\n  'draggable',\n  'enctype',\n  'enterkeyhint',\n  'face',\n  'for',\n  'headers',\n  'height',\n  'hidden',\n  'high',\n  'href',\n  'hreflang',\n  'id',\n  'inputmode',\n  'integrity',\n  'ismap',\n  'kind',\n  'label',\n  'lang',\n  'list',\n  'loading',\n  'loop',\n  'low',\n  'max',\n  'maxlength',\n  'media',\n  'method',\n  'min',\n  'minlength',\n  'multiple',\n  'muted',\n  'name',\n  'nonce',\n  'noshade',\n  'novalidate',\n  'nowrap',\n  'open',\n  'optimum',\n  'pattern',\n  'placeholder',\n  'playsinline',\n  'poster',\n  'preload',\n  'pubdate',\n  'radiogroup',\n  'readonly',\n  'rel',\n  'required',\n  'rev',\n  'reversed',\n  'role',\n  'rows',\n  'rowspan',\n  'spellcheck',\n  'scope',\n  'selected',\n  'shape',\n  'size',\n  'sizes',\n  'span',\n  'srclang',\n  'start',\n  'src',\n  'srcset',\n  'step',\n  'style',\n  'summary',\n  'slot',\n  'tabindex',\n  'title',\n  'translate',\n  'type',\n  'usemap',\n  'valign',\n  'value',\n  'width',\n  'xmlns',\n])\n\n/**\n * @typedef RemovedAttr\n * @property {string}     name - removed attribte name\n * @property {Element}    from - target Element where the attribute was removed\n */\n\n/**\n * @typedef SanitizeHtmlResult\n *\n * The result of `sanitizeI18nHtml`, show the sanitized html as well as the actions performed during sanitization\n *\n * @property {string}        html               - sanitized html result\n * @property {Element[]}     removedElements    - list of removed elements\n * @property {RemovedAttr[]} removedAttributes  - list of removed attributes\n */\n\n/**\n * Initializes a Document and shows its body\n *\n * @param   {string}      html - HTML input string to sanitize\n * @returns {HTMLElement}        Sanitized Html string\n */\nconst _initDocument = (html) => {\n  const doc = new DOMParser().parseFromString('<remove></remove>' + html, 'text/html')\n  doc.body.firstChild?.remove()\n  return doc.body\n}\n\n/**\n * @param {Object}        param\n * @param {Element}       param.currentElement    - current\n * @param {Element[]}     param.removedElements   - list of removed elements, mutable\n * @param {RemovedAttr[]} param.removedAttributes - list of removed attributes, mutable\n */\nconst sanitizeElement = ({ currentElement, removedElements, removedAttributes }) => {\n  if (!ALLOWED_TAGS.has(currentElement.tagName.toLowerCase())) {\n    removedElements.push(currentElement)\n    currentElement.remove()\n    return\n  }\n  const { attributes } = currentElement\n  for (const attribute of Array.from(attributes)) {\n    const name = attribute.name.toLowerCase()\n    if (\n      name === 'data-i18n' ||\n      name.startsWith('data-i18n-') ||\n      (!name.startsWith('data-') && !name.startsWith('aria-') && !ALLOWED_STANDARD_ATTRS.has(name))\n    ) {\n      removedAttributes.push({ name, from: currentElement })\n      attributes.removeNamedItem(name)\n    }\n  }\n\n  for (const child of Array.from(currentElement.children)) {\n    sanitizeElement({ removedElements, removedAttributes, currentElement: child })\n  }\n}\n\n/**\n * Sanitizes The HTML input\n *\n * @param   {string}             html - HTML input string to sanitize\n * @returns {SanitizeHtmlResult} Sanitization result\n */\nexport function sanitizeI18nHtml (html) {\n  /** @type {Element[]} */\n  const removedElements = []\n  /** @type {RemovedAttr[]} */\n  const removedAttributes = []\n  const doc = _initDocument(html)\n  for (const currentElement of Array.from(doc.children)) {\n    sanitizeElement({ removedElements, removedAttributes, currentElement })\n  }\n  return {\n    html: doc.innerHTML,\n    removedElements,\n    removedAttributes,\n  }\n}\n", "import { IterableWeakSet } from '../algorithms/iterable-weak-struct'\nimport { timeNowFrame } from '../algorithms/time.utils'\n\n/**\n * A margin that improves the reliabiliby of the next time value to change\n * due to possible protections to fingerprinting on the client side\n *\n * {@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now}\n */\nconst MARGIN_MILLIS = 100\n\nlet timeTickInstances\n/**\n *\n * @param {TimeTickInstance} newInstance;\n */\nexport function checkTick (newInstance) {\n  const { callbacks, tickingElements, timeoutNumber } = newInstance\n  if (timeoutNumber === undefined && tickingElements.size > 0 && callbacks.size > 0) {\n    const nextSecond = 1000 - timeNowFrame() % 1000\n    newInstance.timeoutNumber = setTimeout(() => {\n      for (const tickCallback of callbacks) {\n        tickCallback({\n          targets: [...tickingElements],\n          untick: (el) => tickingElements.delete(el),\n        })\n      }\n      newInstance.timeoutNumber = undefined\n      checkTick(newInstance)\n    }, nextSecond + MARGIN_MILLIS)\n  }\n}\n\n/**\n * @this {TimeTickInstance}\n * @param {Element} element\n */\nexport function tickElement (element) {\n  this.tickingElements.add(element)\n  checkTick(this)\n}\n\n/**\n * @this {TimeTickInstance}\n * @param {Element} element\n */\nexport function untickElement (element) {\n  this.tickingElements.add(element)\n}\n\n/**\n * @this {TimeTickInstance}\n * @param {TimeTickCallback} callback\n */\nexport function addCallback (callback) {\n  this.callbacks.add(callback)\n  checkTick(this)\n}\n\n/**\n * @this {TimeTickInstance}\n * @param {TimeTickCallback} callback\n */\nexport function removeCallback (callback) {\n  this.callbacks.delete(callback)\n}\n\nfunction TimeTickInstance () {\n  /** @type {IterableWeakSet<Element>} */\n  this.tickingElements = new IterableWeakSet()\n  /** @type {unknown} */\n  this.timeoutNumber = undefined\n  /** @type {Set<TimeTickCallback>} */\n  this.callbacks = new Set()\n}\n\nTimeTickInstance.prototype.tickElement = tickElement\nTimeTickInstance.prototype.untickElement = untickElement\nTimeTickInstance.prototype.addCallback = addCallback\nTimeTickInstance.prototype.removeCallback = removeCallback\n\n/**\n * @returns {TimeTickInstance}\n */\nexport function timeTick () {\n  timeTickInstances ??= new TimeTickInstance()\n  return timeTickInstances\n}\n\n/**\n * @typedef {object} TimeTickCallbackParams\n * @property {Element[]} targets\n * @property {(el: Element) => void} untick\n */\n\n/**\n * @callback TimeTickCallback\n * @param {TimeTickCallbackParams} param\n */\n", "import { normalizeI18nDefinition, normalizeI18nDefinitionMap } from '../i18n-normalizer/i18n-normalizer.js'\n\n/**\n * Add merge data to accumulator\n *\n * @param {I18nMergeIntermediaryResult} acc - acc\n * @param {NormalizedI18nDefinition} i18nDefinition\n * @param {string} language\n * @param {string | URL} locationBase\n * @returns\n */\nconst mergeLang = (acc, i18nDefinition, language, locationBase) => {\n  const { translations, import: ext } = normalizeI18nDefinition(i18nDefinition).result\n  const strLang = language.toString()\n  const definition = acc[strLang] || { import: new Set(), translations: {} }\n  const definitionExtSet = definition.import\n  ext.forEach((e) => {\n    const importLocation = new URL(e, locationBase).href\n    definitionExtSet.add(importLocation)\n  })\n\n  definition.translations = {\n    ...definition.translations,\n    ...translations,\n  }\n\n  acc[strLang] = definition\n  return acc\n}\n\n/**\n *\n * @param  {...I18nLangMergeData} data\n * @returns {NormalizedI18nDefinitionMap}\n */\nconst merge = (...data) => {\n  const result = data.reduce((acc, value) => {\n    const { location, kind } = value\n    const locationStr = typeof location === 'string' ? location : location.href\n    if (kind === 'definition') {\n      const i18nDefinition = normalizeI18nDefinition(value.data).result\n      return mergeLang(acc, i18nDefinition, value.language.toString(), location)\n    }\n\n    if (kind === 'translations') {\n      const i18nDefinition = normalizeI18nDefinition(locationStr).result\n      return mergeLang(acc, i18nDefinition, value.language.toString(), location)\n    }\n\n    const i18nDefinitionMap = normalizeI18nDefinitionMap(value.data).result\n    return Object.entries(i18nDefinitionMap).reduce((acc, [lang, def]) => {\n      return mergeLang(acc, def, lang, location)\n    }, acc)\n  }, {})\n\n  return Object.fromEntries(\n    Object.entries(result).map(([lang, { import: ext, translations }]) => [\n      lang,\n      {\n        import: [...ext],\n        translations,\n      },\n    ]),\n  )\n}\n\n/**\n *\n * @param {I18nLangMergeData[]} data\n * @returns\n */\nconst memoizedMerge = (data) => {\n  let buildResult = () => {\n    const result = merge(...data)\n    buildResult = () => result\n    return result\n  }\n  return () => buildResult()\n}\n\n/**\n *\n * @param {I18nLangMergeData[]} data\n * @returns {MergerInstance}\n */\nconst mergeInstance = (data) => ({\n  addMap: (i18nInfo, location) => mergeInstance([...data, { kind: 'map', data: i18nInfo, location }]),\n  addDefinitionOnLanguage: (i18nDef, language, location) => mergeInstance([...data, { kind: 'definition', language, data: i18nDef, location }]),\n  addTranslations: (location, language) => mergeInstance([...data, { kind: 'translations', language, location }]),\n  build: memoizedMerge(data),\n})\n\nexport const builder = mergeInstance([])\n\n/** @typedef {{[language: string]: {import: Set<string>,translations: Translations}}} I18nMergeIntermediaryResult */\n\n/** @typedef {I18nMapMergeData | I18nDefinitionMergeData | I18nTranslationMergeData } I18nLangMergeData */\n\n/**\n * @typedef {object} I18nMapMergeData\n * @property {'map'} kind\n * @property {I18nDefinitionMap} data\n * @property {URL | string} location\n */\n\n/**\n * @typedef {object} I18nDefinitionMergeData\n * @property {'definition'} kind\n * @property {I18nDefinition} data\n * @property {URL | string} location\n * @property {Intl.Locale | string} language\n */\n\n/**\n * @typedef {object} I18nTranslationMergeData\n * @property {'translations'} kind\n * @property {URL | string} location\n * @property {Intl.Locale | string} language\n */\n\n/**\n * @typedef {object} MergerInstance\n * @property {(i18nInfo: I18nDefinitionMap, location: URL | string) => MergerInstance} addMap\n * @property {(i18nDef: I18nDefinition, language: Intl.Locale | string, location: URL | string) => MergerInstance} addDefinitionOnLanguage\n * @property {(location: URL | string, language: Intl.Locale | string) => MergerInstance} addTranslations\n * @property {() => NormalizedI18nDefinitionMap} build\n */\n\n/** @typedef {import ('../i18n-normalizer/i18n-normalizer.js').I18nDefinitionMap} I18nDefinitionMap */\n/** @typedef {import ('../i18n-normalizer/i18n-normalizer.js').Translations} Translations */\n/** @typedef {import ('../i18n-normalizer/i18n-normalizer.js').I18nDefinition} I18nDefinition */\n/** @typedef {import ('../i18n-normalizer/i18n-normalizer.js').NormalizedI18nDefinition} NormalizedI18nDefinition */\n/** @typedef {import ('../i18n-normalizer/i18n-normalizer.js').NormalizedI18nDefinitionMap} NormalizedI18nDefinitionMap */\n", "import { importI18nJson } from '../utils/i18n-importer/i18n-importer.js'\nimport { i18nTanslationStore } from '../utils/store/translation-store.js'\nimport { builder } from '../utils/i18n-merger/i18n-merger.util.js'\n\n/**\n *\n * @param {LoadPartParameters} params\n * @returns\n */\nasync function loadLocaleMaps ({ document, location, merger }) {\n  const locationHref = location.href\n\n  const localeMaps = Array.from(document.querySelectorAll('link[rel=\"i18n-locale-map\"]'))\n  if (localeMaps.length <= 0) {\n    return merger\n  }\n\n  const deferredMapPromises = localeMaps.flatMap((link) => {\n    const href = link.getAttribute('href')\n    if (!href) return []\n\n    return [importI18nJson(href, locationHref).then((result) => ({ result, location: new URL(href, locationHref) }))]\n  })\n\n  const promiseResults = await Promise.allSettled(deferredMapPromises)\n\n  return promiseResults.reduce((merger, settled) => {\n    if (settled.status === 'rejected') {\n      console.error('error loading file: %o', settled.reason)\n      return merger\n    }\n    const { result, location } = settled.value\n    return merger.addMap(result, location)\n  }, merger)\n}\n\n/**\n *\n * @param {LoadPartParameters} params\n * @returns\n */\nfunction loadTranslations ({ document, location, merger }) {\n  const locationHref = location.href\n\n  const translationsMaps = document.querySelectorAll('link[rel=\"i18n-translation-map\"]')\n  if (translationsMaps.length <= 0) {\n    return merger\n  }\n\n  return [...translationsMaps].reduce((merger, link) => {\n    const href = link.getAttribute('href')\n    const lang = link.getAttribute('lang')\n    if (href == null) {\n      console.error('link %o requires a href attribute, it will be ignored', link)\n      return merger\n    }\n    if (lang == null) {\n      console.error('link %o requires a lang attribute, it will be ignored', link)\n      return merger\n    }\n    try {\n      const locale = new Intl.Locale(lang)\n      return merger.addTranslations(new URL(href, locationHref), locale)\n    } catch {\n      console.error(`invalid locale \"${lang}\", it will be ignored`)\n    }\n    return merger\n  }, merger)\n}\n\n/**\n *\n * @param {LoadI18nParams} params\n * @returns {Promise<import('../utils/store/translation-store.js').TranslationStore>}\n */\nexport async function loadI18n ({ document, location } = window) {\n  location = typeof location === 'string' ? new URL(location) : location\n  const localeMapMerger = await loadLocaleMaps({ document, location, merger: builder })\n  const finalMerger = loadTranslations({ document, location, merger: localeMapMerger })\n\n  const store = i18nTanslationStore()\n\n  store.loadTranslations({\n    location: location.href,\n    languages: finalMerger.build(),\n  })\n\n  return store\n}\n\n/** @typedef {{href: string}} BaseURL - any type that has `href`, like {@link URL} and {@link window.location} */\n\n/**\n * @typedef {object} LoadI18nParams\n *\n * Parameters used to load I18n from the DOM\n *\n * @property {Document} document\n * @property {BaseURL | string} location\n */\n\n/**\n * @typedef {object} LoadPartParameters\n *\n * Parameters used to load I18n from the DOM\n *\n * @property {Document} document\n * @property {BaseURL} location\n * @property {typeof builder} merger\n */\n", "import { ElementLangObserver } from '../../element-lang-observer/element-lang-observer.util.js'\nimport { getLanguageFromElement } from '../../utils/algorithms/get-lang-from-element.util.js'\nimport { isElementTranslatable } from '../../utils/algorithms/get-translate-from-element.util.js'\nimport { getStoresInfoFromElement, setStoreFromElement, isStoreSetOnElement } from '../../utils/store-map/store-map.js'\nimport { queryFromTranslations } from '../../utils/translation-query/translation-query.util.js'\nimport { sanitizeI18nHtml } from '../../utils/html-sanitizer/html-sanitizer.js'\nimport { timeTick } from '../../utils/tick-time/tick-time.js'\nimport { loadI18n } from '../../html-loader/html-loader.js'\n\n/** @type {ReturnType<typeof loadI18n>} */\nlet loadingPromise\nconst pendingElements = new WeakSet()\n\nexport class I18nContainerElement extends HTMLElement {\n  constructor () {\n    super()\n    langObserver.observe(this)\n    mutationObserver.observe(this, mutationProperties)\n\n    const document = this.ownerDocument\n    if (isStoreSetOnElement(document.documentElement)) {\n      return\n    }\n    const window = document.defaultView\n    if (!window) {\n      return\n    }\n\n    if (!loadingPromise) {\n      loadingPromise = loadI18n(window)\n    }\n\n    pendingElements.add(this)\n    loadingPromise.then((store) => {\n      setStoreFromElement(document.documentElement, store)\n      if (this.isConnected) {\n        this.updateNodes()\n        pendingElements.delete(this)\n      }\n    })\n  }\n\n  connectedCallback () {\n    if (!pendingElements.has(this)) {\n      this.updateNodes()\n    }\n  }\n\n  updateNodes () {\n    return updateI18nOnElements(this.querySelectorAll('*')).then((elementsUpdated) => {\n      const result = { elementsUpdated }\n\n      if (elementsUpdated.length <= 0) {\n        return result\n      }\n\n      const event = new CustomEvent('i18n-apply', { bubbles: true, detail: result })\n      this.dispatchEvent(event)\n      return result\n    })\n  }\n}\n\n/**\n *\n * @param {Iterable<Element>} iterable\n * @returns {Promise<Element[]>}\n */\nfunction updateI18nOnElements (iterable) {\n  const promises = []\n  for (const element of iterable) {\n    if (!isElementTranslatable(element) || !element.hasAttributes()) {\n      continue\n    }\n    const attributesToUpdate = getAttributesToUpdate(element)\n    const attributeEntries = Object.entries(attributesToUpdate)\n    const contentDetails = getContentDetailsToUpdate(element)\n    if (attributeEntries.length <= 0 && contentDetails === notFoundContentDetails) {\n      continue\n    }\n    const locale = new Intl.Locale(getLanguageFromElement(element))\n\n    for (const [attribute, i18nKey] of attributeEntries) {\n      const promise = translate(i18nKey, locale, element).then((result) => {\n        if (element.getAttribute(attribute) === result) {\n          return null\n        } else {\n          element.setAttribute(attribute, result)\n          return element\n        }\n      })\n      promises.push(promise)\n    }\n    if (contentDetails !== notFoundContentDetails) {\n      const promise = translate(contentDetails.key, locale, element).then((result) => {\n        const previousHtml = element.innerHTML\n        contentDetails.contentSetter(element, result)\n        return previousHtml === element.innerHTML ? null : element\n      })\n      promises.push(promise)\n    }\n\n    const isTicking = element.hasAttribute('data-i18n-tick-time')\n    if (isTicking) {\n      timeTick().tickElement(element)\n    }\n  }\n\n  return Promise.allSettled(promises).then((promises) => promises.flatMap((promise) => {\n    if (promise.status === 'fulfilled' && promise.value) {\n      return [promise.value]\n    }\n    return []\n  }),\n  )\n}\n\n/**\n * Translte the text content\n * @param {string} text - target text\n * @param {Intl.Locale} locale - language to translate to\n * @param {Element} context - the element where the translation is done\n * @returns {Promise<string>} translated text\n */\nasync function translate (text, locale, context) {\n  for (const storeInfo of getStoresInfoFromElement(context)) {\n    const result = queryFromTranslations(text, await storeInfo.store.translationsFromLanguage(locale))\n    if (result.found) {\n      return result.translate(locale)\n    }\n  }\n  return text\n}\n\n/** @type  {{ [k: string]: number }} */\nconst attributePrefixPriority = {\n  'data-i18n--': 1,\n  'data-i18n-attr-': 2,\n  'data-i18n-attribute-': 3,\n}\n\nconst dataI18nAttributeMatchRegex = /^(data-i18n-(?:attr(?:ibute)?)?-)(.*)$/\n\n/**\n *\n * @param {Element} element\n * @returns {{ [k: string]: string }}\n */\nfunction getAttributesToUpdate (element) {\n  /** @type {{ [k: string]: { prefix: string; value: string } }} */\n  const attributesToUpdate = {}\n  for (const attribute of element.attributes) {\n    const { name, value } = attribute\n    const match = name.match(dataI18nAttributeMatchRegex)\n    if (!match) {\n      continue\n    }\n    const [, prefix, attrName] = match\n    const previous = attributesToUpdate[attrName]\n    if (!previous || attributePrefixPriority[previous.prefix] < attributePrefixPriority[prefix]) {\n      attributesToUpdate[attrName] = { prefix, value }\n    }\n  }\n  return Object.fromEntries(Object.entries(attributesToUpdate).map(([key, val]) => [key, val.value]))\n}\n\nconst contentAttributeDetails = (() => {\n  /** @type {ElementContentSetter} */\n  function setTextContent (element, text) { element.textContent = text }\n  /** @type {ElementContentSetter} */\n  function setInnerHtml (element, text) { element.innerHTML = text }\n  /** @type {ElementContentSetter} */\n  function setSanitizedHtml (element, text) { element.innerHTML = sanitizeI18nHtml(text).html }\n\n  return {\n    'data-i18n-unsafe-html': {\n      priority: 1,\n      contentSetter: setInnerHtml,\n    },\n    'data-i18n-html': {\n      priority: 2,\n      contentSetter: setSanitizedHtml,\n    },\n    'data-i18n': {\n      priority: 2,\n      contentSetter: setTextContent,\n    },\n    'data-i18n-text': {\n      priority: 3,\n      contentSetter: setTextContent,\n    },\n  }\n})()\n\nconst orderedContentAttributeDetails = Object.entries(contentAttributeDetails)\n  .map(([attribute, info]) => ({ ...info, attribute }))\n  .sort((a, b) => b.priority - a.priority)\n\nconst notFoundContentDetails = Object.freeze({\n  attribute: '',\n  key: '',\n  priority: 0,\n  contentSetter: () => {},\n})\n\n/**\n *\n * @param {Element} element\n * @returns {typeof orderedContentAttributeDetails[number] & { key: string }}\n */\nfunction getContentDetailsToUpdate (element) {\n  for (const detail of orderedContentAttributeDetails) {\n    const { attribute } = detail\n    const key = element.getAttribute(attribute)\n    if (key != null) {\n      return {\n        ...detail,\n        key,\n      }\n    }\n  }\n  return notFoundContentDetails\n}\n\nconst targetsToUpdateI18n = {\n  /** @type {Set<Element>} */\n  elements: new Set(),\n  /** @type {Set<Element>} */\n  subtrees: new Set(),\n}\n\nfunction triggerUpdate () {\n  const { elements, subtrees } = targetsToUpdateI18n\n  if (elements.size === 0 && subtrees.size === 0) {\n    return\n  }\n\n  const subTreeTargets = [...subtrees].flatMap((root) => [...root.querySelectorAll('*')])\n  const targets = new Set([...elements, ...subTreeTargets])\n  elements.clear()\n  subtrees.clear()\n  updateI18nOnElements(targets)\n}\n\n/** @type {number | undefined} */\nlet frameRequestNumber\n\n/**\n *\n * @param {MutationRecord[]} records\n */\nfunction observerCallback (records) {\n  const { elements, subtrees } = targetsToUpdateI18n\n  for (const record of records) {\n    const { target, type } = record\n\n    if (!(target instanceof Element) || type !== 'attributes') {\n      continue\n    }\n\n    const { attributeName } = record\n    if (!attributeName) continue\n    if (record.oldValue === target.getAttribute(attributeName)) continue\n    if (attributeName === 'lang') {\n      elements.add(target)\n      subtrees.add(target)\n    } else if (Object.hasOwn(contentAttributeDetails, attributeName) || attributeName.match(dataI18nAttributeMatchRegex)) {\n      elements.add(target)\n    }\n  }\n\n  if (frameRequestNumber === undefined && (elements.size > 0 || subtrees.size > 0)) {\n    frameRequestNumber = requestAnimationFrame(() => {\n      frameRequestNumber = undefined\n      triggerUpdate()\n    })\n  }\n}\n\ntimeTick().addCallback(({ untick, targets }) => {\n  const validTargets = targets.filter((target) => {\n    const isTicking = target.hasAttribute('data-i18n-tick-time')\n    if (!isTicking) {\n      untick(target)\n    }\n    return isTicking\n  })\n  updateI18nOnElements(validTargets)\n})\n\nconst mutationObserver = new MutationObserver(observerCallback)\nconst langObserver = new ElementLangObserver(records => {\n  records.forEach(record => {\n    if (record.target instanceof I18nContainerElement) {\n      record.target.updateNodes()\n    }\n  })\n})\n\n/** @type {MutationObserverInit} */\nconst mutationProperties = Object.freeze({ attributes: true, subtree: true })\n\nexport default I18nContainerElement\n\n/** @typedef { (element: Element, text: string) => void} ElementContentSetter */\n", "/**\n * This JS API is to allow I18n on canvas elements because all the logic goes to JS\n */\nimport { getStoresInfoFromElement, setStoreFromElement, isStoreSetOnElement } from '../utils/store-map/store-map.js'\nimport { queryFromTranslations } from '../utils/translation-query/translation-query.util.js'\nimport { getLanguageFromElement } from '../utils/algorithms/get-lang-from-element.util.js'\nimport { loadI18n } from '../html-loader/html-loader.js'\n\n/**\n * Translates i18n key\n *\n * @param {string} key - target key\n * @param {Context} [context] - context for tranlations\n * @returns {Promise<string>}\n */\nexport async function translate (key, context) {\n  if (!context) {\n    return await i18nFromBrowserLanguage(key)\n  }\n  if ('element' in context && context.element) {\n    const { locale, element } = context\n    const localeStr = locale || getLanguageFromElement(element)\n    return await i18nFromElementAndLocale(key, element, localeStr)\n  }\n  const { locale } = context\n  const localeStr = locale || getLanguageFromElement(document.documentElement)\n  if ('store' in context && context.store) {\n    return await i18nFromStoreAndLocale(key, context.store, localeStr)\n  }\n  return await i18nFromElementAndLocale(key, document.documentElement, localeStr)\n}\n\n/**\n * @param {string} key\n */\nasync function i18nFromBrowserLanguage (key) {\n  return await i18nFromElementAndLocale(key, document.documentElement, getLanguageFromElement(document.documentElement))\n}\n\n/**\n *\n * @param {string} key\n * @param {Element} element\n * @param {string | Intl.Locale} localeString\n * @returns\n */\nasync function i18nFromElementAndLocale (key, element, localeString) {\n  const locale = new Intl.Locale(localeString)\n  if (element?.ownerDocument?.documentElement && !isStoreSetOnElement(element.ownerDocument.documentElement)) {\n    const window = document.defaultView\n    if (!window) { return key }\n    const store = await loadI18n(window)\n    setStoreFromElement(document.documentElement, store)\n  }\n\n  for (const storeInfo of getStoresInfoFromElement(element)) {\n    const result = queryFromTranslations(key, await storeInfo.store.translationsFromLanguage(locale))\n    if (result.found) {\n      return result.translate(locale)\n    }\n  }\n  return key\n}\n\n/**\n *\n * @param {string} key\n * @param {import(\"../utils/store/translation-store.js\").TranslationStore} store\n * @param {string | Intl.Locale} localeString\n * @returns\n */\nasync function i18nFromStoreAndLocale (key, store, localeString) {\n  const locale = new Intl.Locale(localeString)\n  const result = queryFromTranslations(key, await store.translationsFromLanguage(locale))\n  return result.found ? result.translate(locale) : key\n}\n\n/** @typedef {DOMContext| StoreContext | LocaleContext} Context */\n\n/**\n * @typedef {object} DOMContext\n * @property {Element} element\n * @property {string | Intl.Locale} [locale]\n */\n\n/**\n * @typedef {object} StoreContext\n * @property {import(\"../utils/store/translation-store.js\").TranslationStore} store\n * @property {string | Intl.Locale} [locale]\n */\n\n/**\n * @typedef {object} LocaleContext\n * @property {string | Intl.Locale} [locale]\n */\n", "import '../utils/i18n-importer/implementation.js'\nimport { I18nContainerElement as Element } from '../custom-elements/i18n-container/i18n-container.element.js'\nexport { translate } from '../js-api/api.js'\nexport { ElementLangObserver } from '../element-lang-observer/element-lang-observer.util.js'\n\nconst url = new URL(import.meta.url)\nconst elementName = url.searchParams.get('named')\nif (elementName) {\n  if (customElements.get(elementName) != null) {\n    console.error(`A custom element with name \"${elementName}\" already exists`)\n  } else {\n    customElements.define(elementName, Element)\n  }\n}\n\nexport const I18nContainerElement = Element\nexport default I18nContainerElement\n"],
  "mappings": "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AAG,CAClB,CAEA,GAAM,CAAE,aAAAH,CAAa,EAAIc,EACzB,OAAW,CAAE,IAAKG,CAAY,IAAKH,EAAa,mBAAoB,CAClE,GAAM,CAAE,UAAAT,CAAU,EAAIL,EAAaiB,CAAW,EACxCC,EAAQb,EAAU,MAAMF,CAAG,EACjC,GAAIe,EAAM,QAAS,CACjB,IAAMH,EAAgBf,EAAaiB,CAAW,EAAE,MAChD,OAAAJ,EAAMV,CAAG,EAAI,CACX,UAAWA,EACX,aAAAN,EACA,MAAO,GACP,cAAAkB,EACA,UAAWC,GAAoBD,EAAeG,CAAK,CACrD,EACOL,EAAMV,CAAG,CAClB,CACF,CAEA,MAAO,CACL,UAAWA,EACX,aAAAN,EACA,MAAO,GACP,cAAe,GACf,UAAW,IAAMM,CACnB,CACF,CAUA,SAASa,GAAqBD,EAAeG,EAAO,CAClD,IAAMC,EAAaD,GAAO,YAAc,CAAC,EACnCE,EAAoBF,GAAO,mBAAqB,CAAC,EACnDd,EACJ,OAAQiB,IACNjB,IAAUkB,GAAWP,CAAa,EAC3BX,EAAM,OAAOe,EAAYE,EAAQD,CAAiB,EAE7D,CChHO,IAAMG,GAAe,IAAI,IAAI,CAClC,IACA,OACA,UACA,UACA,OACA,UACA,QACA,IACA,MACA,MACA,MACA,aACA,KACA,UACA,SACA,OACA,OACA,MACA,WACA,UACA,OACA,WACA,KACA,YACA,MACA,UACA,MACA,MACA,MACA,KACA,KACA,UACA,KACA,WACA,aACA,SACA,OACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,SACA,KACA,IACA,MACA,MACA,QACA,SACA,KACA,OACA,MACA,OACA,UACA,QACA,MACA,OACA,KACA,IACA,MACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,KACF,CAAC,EAOYC,GAAyB,IAAI,IAAI,CAC5C,SACA,SACA,QACA,MACA,iBACA,eACA,uBACA,WACA,aACA,UACA,SACA,UACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,WACA,eACA,SACA,cACA,WACA,WACA,UACA,MACA,WACA,0BACA,wBACA,WACA,YACA,UACA,eACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,YACA,QACA,OACA,QACA,OACA,OACA,UACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,YACA,WACA,QACA,OACA,QACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,cACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,OACA,WACA,QACA,YACA,OACA,SACA,SACA,QACA,QACA,OACF,CAAC,EAwBKC,GAAiBC,GAAS,CAC9B,IAAMC,EAAM,IAAI,UAAU,EAAE,gBAAgB,oBAAsBD,EAAM,WAAW,EACnF,OAAAC,EAAI,KAAK,YAAY,OAAO,EACrBA,EAAI,IACb,EAQMC,GAAkB,CAAC,CAAE,eAAAC,EAAgB,gBAAAC,EAAiB,kBAAAC,CAAkB,IAAM,CAClF,GAAI,CAACR,GAAa,IAAIM,EAAe,QAAQ,YAAY,CAAC,EAAG,CAC3DC,EAAgB,KAAKD,CAAc,EACnCA,EAAe,OAAO,EACtB,MACF,CACA,GAAM,CAAE,WAAAG,CAAW,EAAIH,EACvB,QAAWI,KAAa,MAAM,KAAKD,CAAU,EAAG,CAC9C,IAAME,EAAOD,EAAU,KAAK,YAAY,GAEtCC,IAAS,aACTA,EAAK,WAAW,YAAY,GAC3B,CAACA,EAAK,WAAW,OAAO,GAAK,CAACA,EAAK,WAAW,OAAO,GAAK,CAACV,GAAuB,IAAIU,CAAI,KAE3FH,EAAkB,KAAK,CAAE,KAAAG,EAAM,KAAML,CAAe,CAAC,EACrDG,EAAW,gBAAgBE,CAAI,EAEnC,CAEA,QAAWC,KAAS,MAAM,KAAKN,EAAe,QAAQ,EACpDD,GAAgB,CAAE,gBAAAE,EAAiB,kBAAAC,EAAmB,eAAgBI,CAAM,CAAC,CAEjF,EAQO,SAASC,GAAkBV,EAAM,CAEtC,IA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",
  "names": ["validateImportPath", "path", "typeOf", "normalizeImportArray", "importArray", "result", "errors", "index", "importPath", "checkResult", "normalizesImportValue", "extdensVal", "normalizeTranslations", "translations", "isPlainObject", "validEntries", "key", "value", "properyPath", "normalizeI18nDefinition", "data", "importArrayResult", "hasimport", "hasTranslations", "importValue", "importValueResult", "message", "mergePath", "translationsValue", "translationsValueResult", "normalizeI18nDefinitionMap", "warnings", "normalizedEntries", "localeString", "i18nDefninition", "locale", "baseName", "normalizedResult", "propPath", "targetVar", "propName", "prop1", "prop2", "defaultImplementation", "implementation", "provide", "newImpl", "importTranslations", "url", "baseUrl", "absoluteUrl", "json", "normalizeResult", "normalizeTranslations", "error", "importI18nJson", "normalizeI18nDefinitionMap", "warning", "provide", "traverseUpDom", "targetElement", "el", "parentNode", "parentElement", "traverseUpDomWithSlots", "assignedSlot", "getFallbackLanguage", "element", "root", "handleInvalidLanguage", "elementWithLangAttr", "invalidLanguage", "getLanguageFromElement", "node", "traverseUpDomWithSlots", "langValue", "locale", "language", "region", "IterableWeakMap", "iterable", "key", "value", "dataOf", "keySet", "refWeakMap", "entry", "callback", "thisArg", "array", "ref", "deref", "refVal", "IterableWeakSet", "map", "init", "iter", "result", "getData", "rootNodes", "IterableWeakMap", "data", "observingElementsInfo", "rootEventName", "ElementLangObserver", "callback", "data", "element", "observeLangFromElement", "unobserveLangFromElement", "mutationProperties", "langMutationObserverCallback", "records", "triggeredNodes", "validatedNodes", "rootNodesToTrigger", "record", "rootNode", "observingElements", "rootNodes", "node", "info", "observingElementsInfo", "oldLang", "newLang", "getLanguageFromElement", "observer", "event", "createObserver", "targetNode", "traverseRootNode", "observeInfomation", "IterableWeakSet", "host", "oldVal", "observers", "isElementTranslatable", "element", "node", "traverseUpDomWithSlots", "translateValue", "importTranslations", "url", "base", "implementation", "importI18nJson", "emptyObj", "intialDataStore", "normalizeTranslationData", "data", "normalizedLanguages", "normalizeI18nDefinitionMap", "error", "memoizedTranslationsMap", "getMemoizedTranslations", "store", "memoizedTranslations", "newMemo", "getTranslationsFromData", "locale", "computed", "definition", "translationsPromises", "extend", "importTranslations", "importedTranslations", "acc", "translations", "StorePrototype", "languages", "intlLang", "langRegion", "language", "result", "i18nTanslationStore", "fallbackStore", "i18nTanslationStore", "noStoresFound", "map", "isStoreSetOnElement", "element", "map", "setStoreFromElement", "store", "getStoresInfoFromElement", "target", "traverseUpDom", "noStoresFound", "states", "ch", "char", "defaultNextState", "state", "normalState", "captureState", "captureExprState", "regexState", "singleQuoteStringState", "doubleQuoteStringState", "backtickStringState", "stateMachine", "getAST", "key", "currentState", "currentMachineState", "rootnode", "currentToken", "setCurrentState", "newState", "isRootNode", "node", "upOneLevel", "index", "parentNode", "length", "i", "nextState", "toToken", "start", "end", "type", "childTokens", "substring", "text", "isNumeric", "str", "isInteger", "parseISO8601", "text", "iso8601Regex", "timeNowFrame", "frameTime", "formatAsIs", "text", "baseFormatter", "locale", "date", "isNumeric", "parseISO8601", "defaultDateFormatOptions", "defaultDateTimeFormatOptions", "timestampFormatOptions", "longDateFormatOptions", "longDateTimeFormatOptions", "durationUnitsEntries", "baseRelativeTimeFormatter", "relativeTimeFormat", "relativeTimeDurationFormatter", "relativeTimeDurationFormat", "baseInUnitRelativeTimeFormatter", "unit", "relativeTimeFormatInUnit", "baseDurationInUnitRelativeTimeFormatter", "relativeTimeDurationFormatInUnit", "baseToUnitRelativeTimeFormatter", "duration", "relativeTimeFormatToUnit", "relativeTimeFormatters", "result", "baseKey", "unitPostfix", "unitParams", "d1", "d2", "timeNowFrame", "elapsed", "formatter", "durationUnit", "toUnit", "listFormatter", "timeUnitFormatter", "list", "amount", "formatters", "defaultFormat", "formatters", "baseCapureExpressions", "text", "isNumeric", "specialCapureExpressions", "match", "regexPattern", "regex", "baseTimeCaptureExpressions", "parseISO8601", "relativeTimeCaptureExpresionPrefix", "prev", "predicate", "timeIntervalCaptureExpresionPrefix", "timeText", "timeNow", "timeNowFrame", "date", "dateNow", "yearNow", "yeardiff", "onejan", "onejanDay", "onejanTimeStamp", "weekNow", "buildTimeCaptureExpressions", "entries", "fromEntries", "baseKey", "baseInfo", "result", "relativePrefixKey", "relativePrefixInfo", "infoWithRelTime", "intervalKey", "intervalnfo", "captureExpressions", "calculatePriority", "ast", "calculatePriorityFromTokens", "tokens", "captureTokens", "token", "states", "captureValues", "sum", "calculateCaptureTokenPriority", "a", "b", "getNumericValuePriority", "captureToken", "captureExpressions", "value", "currentExpression", "captures", "escape", "pattern", "falsePredicate", "emptyArray", "anyMatchExpression", "captureExpressions", "noMatchExpression", "anyMatchCaptureExpressionsInfo", "noMatch", "emptyYesMatch", "exactStringMatcher", "textToMatch", "text", "getMatcherFromTokens", "tokens", "captureTokens", "token", "states", "captureExpressionsInfo", "captureToken", "fragmentedCaptureExpressionsInfo", "currentExpression", "expressionPart", "regexStr", "escape", "regex", "matches", "parameters", "paramMatchInfo", "index", "matchResult", "defaultFormatters", "info", "getMatcher", "ast", "normalizeDefaultToken", "token", "normalizedCaptureToken", "childTokens", "normalizedCapture", "normalizeToken", "i", "e", "previousToken", "states", "normalizeTokenMapper", "getNormalizedKey", "ast", "parseKey", "key", "getAST", "priority", "priorityAsNumber", "calculatePriority", "match", "getMatcher", "normalizedKey", "text", "emptyArray", "formatterWithFormat", "templateFormatter", "parameters", "locale", "defaultFormatters", "strings", "formatters", "result", "i", "e", "formatSimpleKey", "value", "parseCaptureKey", "captureToken", "fragmentedCaptureExpressionsInfo", "currentExpression", "token", "states", "applyDefaultformatter", "acc", "positionFormatter", "position", "reducerFormatter", "fragmentedFormatters", "reducerAcc", "fragmentedFormatter", "getFormatterFromTokens", "tokens", "textToMatch", "keyToken", "firstInfo", "restInfo", "text", "isInteger", "info", "formatter", "getFormatter", "ast", "tokenToString", "mapper", "defaultMapper", "token", "states", "childTokens", "normalizedCapture", "i", "e", "previousToken", "getNormalizedValue", "ast", "parseValue", "value", "getAST", "formatter", "getFormatter", "normalizedValue", "optimizeTranslationForQueries", "translations", "result", "literalKeys", "templateKeys", "sortedTemplateKeys", "prefixTemplateSearchByWords", "key", "value", "parsedKey", "parseKey", "optimizedTemplateKey", "prefix", "b", "translationOptimizations", "queryFromTranslations", "optmization", "cache", "optimizedMap", "valueTemplate", "translatorFromValue", "templateKey", "match", "parameters", "defaultFormatters", "locale", "parseValue", "ALLOWED_TAGS", "ALLOWED_STANDARD_ATTRS", "_initDocument", "html", "doc", "sanitizeElement", "currentElement", "removedElements", "removedAttributes", "attributes", "attribute", "name", "child", "sanitizeI18nHtml", "MARGIN_MILLIS", "timeTickInstances", "checkTick", "newInstance", "callbacks", "tickingElements", "timeoutNumber", "nextSecond", "timeNowFrame", "tickCallback", "el", "tickElement", "element", "untickElement", "addCallback", "callback", "removeCallback", "TimeTickInstance", "IterableWeakSet", "timeTick", "mergeLang", "acc", "i18nDefinition", "language", "locationBase", "translations", "ext", "normalizeI18nDefinition", "strLang", "definition", "definitionExtSet", "e", "importLocation", "merge", "data", "result", "value", "location", "kind", "locationStr", "i18nDefinitionMap", "normalizeI18nDefinitionMap", "lang", "def", "memoizedMerge", "buildResult", "mergeInstance", "i18nInfo", "i18nDef", "builder", "loadLocaleMaps", "document", "location", "merger", "locationHref", "localeMaps", "deferredMapPromises", "link", "href", "importI18nJson", "result", "settled", "loadTranslations", "translationsMaps", "lang", "locale", "loadI18n", "localeMapMerger", "builder", "finalMerger", "store", "i18nTanslationStore", "loadingPromise", "pendingElements", "I18nContainerElement", "langObserver", "mutationObserver", "mutationProperties", "document", "isStoreSetOnElement", "window", "loadI18n", "store", "setStoreFromElement", "updateI18nOnElements", "elementsUpdated", "result", "event", "iterable", "promises", "element", "isElementTranslatable", "attributesToUpdate", "getAttributesToUpdate", "attributeEntries", "contentDetails", "getContentDetailsToUpdate", "notFoundContentDetails", "locale", "getLanguageFromElement", "attribute", "i18nKey", "promise", "translate", "previousHtml", "timeTick", "text", "context", "storeInfo", "getStoresInfoFromElement", "queryFromTranslations", "attributePrefixPriority", "dataI18nAttributeMatchRegex", "name", "value", "match", "prefix", "attrName", "previous", "key", "val", "contentAttributeDetails", "setTextContent", "setInnerHtml", "setSanitizedHtml", "sanitizeI18nHtml", "orderedContentAttributeDetails", "info", "a", "b", "detail", "targetsToUpdateI18n", "triggerUpdate", "elements", "subtrees", "subTreeTargets", "root", "targets", "frameRequestNumber", "observerCallback", "records", "record", "target", "type", "attributeName", "untick", "validTargets", "isTicking", "ElementLangObserver", "translate", "key", "context", "i18nFromBrowserLanguage", "locale", "element", "localeStr", "getLanguageFromElement", "i18nFromElementAndLocale", "i18nFromStoreAndLocale", "localeString", "isStoreSetOnElement", "window", "store", "loadI18n", "setStoreFromElement", "storeInfo", "getStoresInfoFromElement", "result", "queryFromTranslations", "url", "elementName", "I18nContainerElement", "browser_default"]
}
